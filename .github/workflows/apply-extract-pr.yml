name: Apply Extract PR

on:
  workflow_dispatch:
    inputs:
      pr_title:
        description: 'PR title'
        required: false
        default: 'chore: standardize Extract client to match medx-ingest-api and add smoke test'
      pr_body:
        description: 'PR body'
        required: false
        default: 'Adds a standardized Extract client and smoke test workflow. See files added: src/services/avidiaExtractToIngest.ts, src/app/api/v1/ingest/[id]/route.ts, types/ingest.d.ts, scripts/run-extract.ts, package.json, .github/workflows/dispatch-extract.yml, docs/EXTRACT.md.\n\nRequired secrets for smoke tests: INGEST_API_ENDPOINT, INGEST_API_KEY.'
      branch_name:
        description: 'Branch name to create (optional)'
        required: false
        default: ''

permissions:
  contents: write
  pull-requests: write

jobs:
  create-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup git identity
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Determine branch name
        id: vars
        run: |
          if [ -n "${{ github.event.inputs.branch_name }}" ]; then
            echo "branch=${{ github.event.inputs.branch_name }}" >> $GITHUB_OUTPUT
          else
            BR="chore/standardize-extract-$(date +%F)-${GITHUB_RUN_ID}"
            echo "branch=$BR" >> $GITHUB_OUTPUT
          fi

      - name: Create branch
        run: |
          git checkout -b ${{ steps.vars.outputs.branch }}

      - name: Add files
        run: |
          mkdir -p src/services src/app/api/v1/ingest types scripts .github/workflows docs

          cat > src/services/avidiaExtractToIngest.ts <<'EOF'
/**
 * src/services/avidiaExtractToIngest.ts
 *
 * Thin, robust TypeScript client for the central medx-ingest-api.
 * - Exports extractAndIngest(targetUrl, opts)
 * - Uses global fetch when available (Node 18+ or Next server runtime). Falls back to node-fetch@2.
 * - Supports configurable ingest endpoint and API key via opts or env vars.
 * - Built-in timeout + retry (exponential backoff).
 */
type ExtractOpts = {
  ingestApiEndpoint?: string;
  ingestApiKey?: string;
  timeoutMs?: number;
  retries?: number;
  retryDelayMs?: number;
};
function isValidHttpUrl(s: string) {
  try {
    const u = new URL(s);
    return u.protocol === 'http:' || u.protocol === 'https:';
  } catch {
    return false;
  }
}
async function getFetch(): Promise<typeof fetch> {
  // prefer global fetch (Node 18+, Next runtime)
  // @ts-ignore
  if (typeof globalThis.fetch === 'function') return globalThis.fetch;
  // fallback to node-fetch v2 (CommonJS)
  try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const nf = require('node-fetch');
    return nf;
  } catch (err) {
    throw new Error(
      'No fetch available. Use Node 18+ or add node-fetch@2 to dependencies (npm i node-fetch@2).'
    );
  }
}
function timeoutPromise<T>(p: Promise<T>, ms: number, controller?: AbortController): Promise<T> {
  if (ms <= 0) return p;
  return new Promise<T>((resolve, reject) => {
    const timer = setTimeout(() => {
      try {
        controller?.abort();
      } catch {}
      reject(new Error(`Request timed out after ${ms}ms`));
    }, ms);
    p.then((v) => {
      clearTimeout(timer);
      resolve(v);
    }, (err) => {
      clearTimeout(timer);
      reject(err);
    });
  });
}
export async function extractAndIngest(targetUrl: string, opts: ExtractOpts = {}): Promise<any> {
  if (!targetUrl || typeof targetUrl !== 'string') {
    throw new TypeError('targetUrl (string) required');
  }
  if (!isValidHttpUrl(targetUrl)) {
    throw new TypeError('targetUrl must be a valid http(s) URL');
  }
  const ingestApiEndpoint =
    opts.ingestApiEndpoint ||
    process.env.INGEST_API_ENDPOINT ||
    'https://medx-ingest-api.onrender.com';
  const ingestApiKey = opts.ingestApiKey || process.env.INGEST_API_KEY || '';
  const timeoutMs = opts.timeoutMs ?? 120_000;
  const retries = Math.max(1, Math.floor(opts.retries ?? 3));
  const retryDelayMs = opts.retryDelayMs ?? 300;
  const fetchFn = await getFetch();
  let lastErr: any = null;
  for (let attempt = 1; attempt <= retries; attempt++) {
    const controller =
      typeof AbortController !== 'undefined' ? new AbortController() : (null as any);
    try {
      const url = `${ingestApiEndpoint.replace(/\/$/, '')}/ingest?url=${encodeURIComponent(
        targetUrl
      )}`;
      const headers: Record<string, string> = {
        Accept: 'application/json',
      };
      if (ingestApiKey) headers['x-api-key'] = ingestApiKey;
      const resPromise = fetchFn(url, {
        method: 'GET',
        headers,
        signal: controller ? controller.signal : undefined,
      });
      const res = await timeoutPromise(resPromise as Promise<Response>, timeoutMs, controller);
      if (!res.ok) {
        let bodyText = '';
        try {
          bodyText = await (res.text ? res.text() : Promise.resolve(''));
        } catch {}
        const err = new Error(
          `Ingest API returned ${res.status} ${res.statusText}${bodyText ? `: ${bodyText}` : ''}`
        );
        // @ts-ignore
        err.status = res.status;
        throw err;
      }
      const json = await (res.json ? res.json() : Promise.resolve(null));
      return json;
    } catch (err: any) {
      lastErr = err;
      const isAbort = String(err?.message || '').toLowerCase().includes('aborted') || String(err?.message || '').toLowerCase().includes('timeout');
      if (attempt === retries) break;
      const delay = Math.round(retryDelayMs * Math.pow(2, attempt - 1));
      // eslint-disable-next-line no-console
      console.warn(
        `extractAndIngest attempt ${attempt} failed${isAbort ? ' (timeout/abort)' : ''}: ${err?.message || err}. Retrying in ${delay}ms...`
      );
      await new Promise((r) => setTimeout(r, delay));
      continue;
    } finally {
      // no-op
    }
  }
  const finalErr = new Error(`extractAndIngest failed after ${retries} attempts: ${lastErr?.message || lastErr}`);
  // @ts-ignore
  finalErr.cause = lastErr;
  throw finalErr;
}
export default { extractAndIngest };
EOF

          cat > src/app/api/v1/ingest/[id]/route.ts <<'EOF'
/**
 * src/app/api/v1/ingest/[id]/route.ts
 *
 * GET /api/v1/ingest/{id}?url=<encoded-url>
 * Proxies to extractAndIngest and returns { ok: true, data } on success.
 *
 * NOTE: fixed import path to correctly reach src/services from this file and used NextRequest/params handling.
 */
import { NextResponse, type NextRequest } from 'next/server';
import { extractAndIngest } from '../../../../../services/avidiaExtractToIngest';

export async function GET(
  request: NextRequest,
  context: { params: { id: string } | Promise<{ id: string }> }
) {
  try {
    // handle both sync and promise-style params:
    const params = await Promise.resolve(context.params);
    const id = params?.id;

    const urlParam = new URL(request.url).searchParams.get('url');

    if (!urlParam) {
      return NextResponse.json({ ok: false, error: 'Missing url query parameter' }, { status: 400 });
    }

    // call the adapter (server-side)
    const result = await extractAndIngest(urlParam, {
      timeoutMs: 120_000,
      retries: 3,
    });

    return NextResponse.json({ ok: true, data: result }, { status: 200 });
  } catch (err: any) {
    // eslint-disable-next-line no-console
    console.error('API ingest error:', err?.message || err, { stack: err?.stack });

    // If the adapter provided a status (from upstream), map 4xx/5xx to 502/whatever is appropriate
    const upstreamStatus = (err?.status && Number(err.status)) || null;
    const status = upstreamStatus && upstreamStatus >= 400 && upstreamStatus < 600 ? 502 : 500;
    const message = err?.message || 'Unknown error contacting ingest API';
    return NextResponse.json({ ok: false, error: message }, { status });
  }
}
EOF

          cat > types/ingest.d.ts <<'EOF'
// types/ingest.d.ts
// Common fields returned by medx-ingest-api. This is intentionally partial â€” add fields as needed.

export interface DescAudit {
  score?: number;
  passed?: boolean;
  violations?: Array<{ code: string; message: string; severity?: string }>; 
  [k: string]: any;
}

export interface IngestResult {
  source?: string;
  name_best?: string;
  short_name_60?: string;
  name_raw?: string;
  description_raw?: string;
  desc_audit?: DescAudit;
  features_html?: string;
  features_structured?: any;
  specs_structured?: any;
  pdf_manual_urls?: string[];
  images?: string[];
  quality_score?: number;
  needs_review?: boolean;
  sections?: any;
  // Allow other fields:
  [k: string]: any;
}
EOF

          cat > scripts/run-extract.ts <<'EOF'
#!/usr/bin/env ts-node
/**
 * scripts/run-extract.ts
 *
 * Usage:
 *   npx ts-node -O '{"module":"commonjs"}' scripts/run-extract.ts "https://www.apple.com/iphone-17/"
 *
 * Environment:
 *   INGEST_API_ENDPOINT (optional)
 *   INGEST_API_KEY (optional)
 */

import path from 'path';

async function main() {
  const targetUrl = process.env.TARGET_URL || process.argv[2] || 'https://www.apple.com/iphone-17/';
  console.log('Target URL:', targetUrl);

  let adapter: any;
  const adapterTs = path.resolve(__dirname, '../src/services/avidiaExtractToIngest');
  const adapterDist = path.resolve(__dirname, '../dist/src/services/avidiaExtractToIngest');

  try {
    adapter = await import(adapterTs);
  } catch (err) {
    try {
      adapter = await import(adapterDist);
    } catch (err2) {
      console.error('Failed to import adapter from src/services or dist. Ensure file exists and is compiled if necessary.');
      console.error(err, err2);
      process.exit(2);
    }
  }

  const fn = adapter.extractAndIngest || (adapter.default && adapter.default.extractAndIngest);
  if (typeof fn !== 'function') {
    console.error('extractAndIngest not found on imported module:', Object.keys(adapter));
    process.exit(3);
  }

  const ingestEndpoint = process.env.INGEST_API_ENDPOINT;
  const ingestKey = process.env.INGEST_API_KEY;

  try {
    console.log('Calling ingest API via adapter...');
    const result = await fn(targetUrl, { ingestApiEndpoint: ingestEndpoint, ingestApiKey: ingestKey, timeoutMs: 120_000, retries: 3 });

    console.log('=== Ingest result summary ===');
    if (!result || typeof result !== 'object') {
      console.error('Ingest returned no JSON or non-object result:', result);
      process.exit(4);
    }
    const keys = Object.keys(result);
    console.log('Top-level keys:', keys.join(', '));
    if (result.name_best) console.log('name_best:', result.name_best);
    if (result.short_name_60) console.log('short_name_60:', result.short_name_60);
    if (result.desc_audit) console.log('desc_audit:', JSON.stringify(result.desc_audit, null, 2));
    if (result.pdf_manual_urls) console.log('pdf_manual_urls:', JSON.stringify(result.pdf_manual_urls, null, 2));

    const s = JSON.stringify(result, null, 2);
    if (s.length <= 8000) console.log('Full JSON:\n', s);
    else console.log('Result size:', s.length, 'chars; first 8000 chars:\n', s.slice(0, 8000));

    console.log('=== End summary ===');
    process.exit(0);
  } catch (err: any) {
    console.error('ERROR calling ingest API:', err?.message || err);
    if (err?.stack) console.error(err.stack);
    process.exit(5);
  }
}

main();
EOF

          cat > package.json <<'EOF'
{
  "name": "avidiatech-app",
  "version": "1.0.0",
  "private": true,
  "engines": {
    "node": ">=18"
  },
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "smoke-extract": "ts-node -O '{\"module\":\"commonjs\"}' scripts/run-extract.ts"
  },
  "dependencies": {
    "@clerk/nextjs": "^5.0.0",
    "@supabase/supabase-js": "^2.81.1",
    "autoprefixer": "^10.4.16",
    "next": "latest",
    "node-fetch": "^2.7.0",
    "postcss": "^8.4.31",
    "react": "latest",
    "react-dom": "latest",
    "tailwindcss": "^3.4.0",
    "stripe": "^12.0.0",
    "openai": "^4.8.0",
    "zod": "^3.22.2"
  },
  "devDependencies": {
    "@types/node": "^20.5.9",
    "@types/node-fetch": "^2.6.13",
    "@types/react": "^18.2.48",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.3"
  }
}
EOF

          cat > .github/workflows/dispatch-extract.yml <<'EOF'
name: Dispatch - Run Avidia Extract smoke test

on:
  workflow_dispatch:
    inputs:
      url:
        description: 'Target product URL to ingest'
        required: true
        default: 'https://www.apple.com/iphone-17/'

permissions:
  contents: read

jobs:
  run-smoke:
    name: Run extract smoke test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Use Node.js 20.x
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies (strict)
        run: |
          if [ -f package-lock.json ]; then
            npm ci --prefer-offline --no-audit
          elif [ -f package.json ]; then
            npm install --prefer-offline --no-audit
          else
            echo "No package.json found; skipping install"
          fi

      - name: Run TypeScript smoke script with ts-node
        env:
          TARGET_URL: ${{ github.event.inputs.url }}
          INGEST_API_ENDPOINT: ${{ secrets.INGEST_API_ENDPOINT }}
          INGEST_API_KEY: ${{ secrets.INGEST_API_KEY }}
        run: |
          npx ts-node -O '{"module":"commonjs"}' scripts/run-extract.ts "${{ github.event.inputs.url }}"
EOF

      - name: Commit & push
        run: |
          git add .
          git commit -m "chore: standardize Extract client + smoke test + workflow" || echo "no changes to commit"
          git push --set-upstream origin ${{ steps.vars.outputs.branch }}

      - name: Create Pull Request
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const branch = "${{ steps.vars.outputs.branch }}";
            const title = `${{ github.event.inputs.pr_title }}`;
            const body = `${{ github.event.inputs.pr_body }}`;
            const pr = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: branch,
              base: 'main',
              title,
              body,
              maintainer_can_modify: true
            });
            core.setOutput('pr_number', pr.data.number);
            console.log(`Created PR #${pr.data.number}: ${pr.data.html_url}`);

      - name: Output PR URL
        run: |
          echo "PR created (check Actions log for URL)."
