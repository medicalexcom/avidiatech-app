{"version":3,"sources":["../../../src/lib/clerkSafe.ts","../../../src/lib/gpt/loadInstructions.ts"],"sourcesContent":["// url=https://github.com/medicalexcom/avidiatech-app/blob/main/src/lib/clerkSafe.ts\n/**\n * safeGetAuth(req)\n *\n * Defensive wrapper around Clerk's getAuth for environments where clerkMiddleware\n * may not be initialized (build / CI / tests). Returns a minimal auth object or\n * { userId: null } on error rather than allowing getAuth() to run unchecked.\n *\n * Usage: call safeGetAuth(req) INSIDE your request handlers (not at module top-level).\n */\nexport function safeGetAuth(req: any): { userId?: string | null; sessionId?: string | null; actor?: any } {\n  // Quick short-circuit: if essential Clerk env is not present, avoid requiring Clerk.\n  // This prevents build-time/CI warnings where Clerk can't detect middleware.\n  if (!process.env.CLERK_SECRET && !process.env.NEXT_PUBLIC_CLERK_FRONTEND_API && !process.env.NEXT_PUBLIC_CLERK_FRONTEND) {\n    return { userId: null };\n  }\n\n  try {\n    // Require at runtime to avoid top-level Clerk initialization during build\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const clerk = require(\"@clerk/nextjs/server\");\n    if (clerk && typeof clerk.getAuth === \"function\") {\n      try {\n        // getAuth expects the Next Request-like object in your handlers\n        return clerk.getAuth(req);\n      } catch (err) {\n        // getAuth might still throw if middleware not detected; swallow it and return null userId\n        // but keep the error in logs for diagnostics\n        // eslint-disable-next-line no-console\n        console.warn(\"safeGetAuth: getAuth threw:\", String(err));\n        return { userId: null };\n      }\n    }\n  } catch (e) {\n    // Clerk package not available or require failed (build/CI). Return safe fallback.\n    // eslint-disable-next-line no-console\n    console.warn(\"safeGetAuth: @clerk/nextjs/server not available at runtime:\", String(e));\n    return { userId: null };\n  }\n\n  return { userId: null };\n}\n","/**\n * loadInstructions.ts\n *\n * REQUIRED POLICY (per repo requirement):\n * - The ONLY instruction source is the local canonical file:\n *     tools/render-engine/prompts/custom_gpt_instructions.md\n * - No tenant overrides\n * - No GitHub raw fetch fallbacks\n * - Fail hard if missing/empty (callers must not proceed without instructions)\n *\n * Exports:\n * - loadCustomGptInstructions(tenantId?) -> Promise<string>  (backwards-compatible, but now throws on missing)\n * - loadCustomGptInstructionsWithInfo(tenantId?) -> Promise<{ text: string, source: \"local\" }>\n */\n\nimport path from \"path\";\nimport fs from \"fs/promises\";\n\ntype InstrSource = \"local\";\n\nlet cached: { value: string; fetchedAt: number; source: InstrSource } | null = null;\n\nconst DEFAULT_TTL = parseInt(process.env.RENDER_PROMPTS_TTL_SECONDS || \"600\", 10);\nconst CANONICAL_PATH = path.join(\n  process.cwd(),\n  \"tools\",\n  \"render-engine\",\n  \"prompts\",\n  \"custom_gpt_instructions.md\"\n);\n\nasync function readCanonicalInstructions(): Promise<string> {\n  const stat = await fs.stat(CANONICAL_PATH).catch(() => null);\n  if (!stat || !stat.isFile()) {\n    throw new Error(`custom_gpt_instructions_missing_or_empty: missing ${CANONICAL_PATH}`);\n  }\n\n  const txt = await fs.readFile(CANONICAL_PATH, { encoding: \"utf8\" });\n  if (!txt || txt.trim().length === 0) {\n    throw new Error(`custom_gpt_instructions_missing_or_empty: empty ${CANONICAL_PATH}`);\n  }\n\n  // eslint-disable-next-line no-console\n  console.info(\"loadInstructions: loaded local prompt from\", CANONICAL_PATH);\n  return txt;\n}\n\n/**\n * Returns text only.\n * NOTE: this now THROWS if missing/empty to enforce strict compliance.\n */\nexport default async function loadCustomGptInstructions(_tenantId?: string | null): Promise<string> {\n  const info = await loadCustomGptInstructionsWithInfo(_tenantId);\n  return info.text;\n}\n\n/**\n * Return text and source info.\n */\nexport async function loadCustomGptInstructionsWithInfo(_tenantId?: string | null): Promise<{ text: string; source: InstrSource }> {\n  const now = Date.now();\n  if (cached && (now - cached.fetchedAt) / 1000 < DEFAULT_TTL) {\n    return { text: cached.value, source: \"local\" };\n  }\n\n  const txt = await readCanonicalInstructions();\n  cached = { value: txt, fetchedAt: Date.now(), source: \"local\" };\n  return { text: txt, source: \"local\" };\n}\n\nexport function clearLoadInstructionsCache() {\n  cached = null;\n}\n"],"names":[],"mappings":"qLAUO,SAAS,EAAY,CAAQ,EAGlC,GAAI,CAAC,QAAQ,GAAG,CAAC,YAAY,EAAI,CAAC,QAAQ,GAAG,CAAC,8BAA8B,EAAI,CAAC,QAAQ,GAAG,CAAC,0BAA0B,CACrH,CADuH,KAChH,CAAE,OAAQ,IAAK,EAGxB,GAAI,CAGF,IAAM,EAAA,EAAA,CAAA,CAAA,MACN,GAAI,GAAkC,YAAzB,AAAqC,OAA9B,EAAM,OAAO,CAC/B,GAAI,CAEF,OAAO,EAAM,OAAO,CAAC,EACvB,CAAE,MAAO,EAAK,CAIZ,QAAQ,IAAI,CAAC,8BAA+B,OAAO,GAErD,CAEJ,CAAE,MAAO,EAAG,CAGV,QAAQ,IAAI,CAAC,8DAA+D,OAAO,GAErF,CAEA,MAAO,CAAE,OAAQ,IAAK,CACxB,6HC1BA,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OAIA,IAAI,EAA2E,KAEzE,EAAc,SAAS,QAAQ,GAAG,CAAC,0BAA0B,EAAI,MAAO,IACxE,EAAiB,EAAA,OAAI,CAAC,IAAI,CAC9B,QAAQ,GAAG,GACX,QACA,gBACA,UACA,8BAGF,eAAe,IACb,IAAM,EAAO,MAAM,EAAA,OAAE,CAAC,IAAI,CAAC,GAAgB,KAAK,CAAC,IAAM,MACvD,GAAI,CAAC,GAAQ,CAAC,EAAK,MAAM,GACvB,CAD2B,KACrB,AAAI,MAAM,CAAC,kDAAkD,EAAE,EAAA,CAAgB,EAGvF,IAAM,EAAM,MAAM,EAAA,OAAE,CAAC,QAAQ,CAAC,EAAgB,CAAE,SAAU,MAAO,GACjE,GAAI,CAAC,GAA6B,GAAG,CAAzB,EAAI,IAAI,GAAG,MAAM,CAC3B,MAAM,AAAI,MAAM,CAAC,gDAAgD,EAAE,EAAA,CAAgB,EAKrF,OADA,QAAQ,IAAI,CAAC,6CAA8C,GACpD,CACT,CAcO,eAAe,EAAkC,CAAyB,EAC/E,IAAM,EAAM,KAAK,GAAG,GACpB,GAAI,GAAU,CAAC,EAAM,EAAO,SAAA,AAAS,EAAI,IAAO,EAC9C,MAAO,CAAE,IADkD,CAC5C,EAAO,KAAK,CAAE,OAAQ,OAAQ,EAG/C,IAAM,EAAM,MAAM,IAElB,OADA,EAAS,CAAE,MAAO,EAAK,UAAW,KAAK,GAAG,GAAI,OAAQ,OAAQ,EACvD,CAAE,KAAM,EAAK,OAAQ,OAAQ,CACtC"}