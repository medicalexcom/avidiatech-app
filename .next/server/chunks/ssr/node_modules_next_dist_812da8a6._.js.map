{"version":3,"sources":["../../../../node_modules/next/src/client/components/router-reducer/router-reducer-types.ts","../../../../node_modules/next/src/shared/lib/is-thenable.ts","../../../../node_modules/next/src/client/components/use-action-queue.ts","../../../../node_modules/next/src/client/app-call-server.ts","../../../../node_modules/next/src/client/app-find-source-map-url.ts","../../../../node_modules/next/src/shared/lib/router/utils/remove-trailing-slash.ts","../../../../node_modules/next/src/shared/lib/page-path/ensure-leading-slash.ts","../../../../node_modules/next/src/shared/lib/router/utils/app-paths.ts","../../../../node_modules/next/src/shared/lib/router/utils/interception-routes.ts","../../../../node_modules/next/src/shared/lib/utils.ts","../../../../node_modules/next/src/shared/lib/router/utils/querystring.ts","../../../../node_modules/next/src/shared/lib/router/utils/format-url.ts","../../../../node_modules/next/src/shared/lib/router/utils/parse-path.ts","../../../../node_modules/next/src/client/normalize-trailing-slash.ts","../../../../node_modules/next/src/shared/lib/router/utils/path-has-prefix.ts","../../../../node_modules/next/src/client/has-base-path.ts","../../../../node_modules/next/src/shared/lib/router/utils/add-path-prefix.ts","../../../../node_modules/next/src/client/add-base-path.ts","../../../../node_modules/next/src/shared/lib/router/utils/is-local-url.ts","../../../../node_modules/next/src/shared/lib/utils/warn-once.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  navigatedAt,\n  previousTree,\n  serverResponse,\n}: {\n  navigatedAt: number\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  renderedSearch?: string\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n  onlyHashChange?: boolean\n  collectedDebugInfo?: Array<unknown>\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n  origin: Location['origin']\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n  origin: Location['origin']\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n  didRevalidate?: boolean\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  historyState: AppHistoryState | undefined\n}\n\nexport type AppHistoryState = {\n  tree: FlightRouterState\n  renderedSearch: string\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n * - Only triggered in layout-router.\n * - Creates a new cache and router state with the Flight data applied.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  navigatedAt: number\n  serverResponse: FetchServerResponseResult\n  previousTree: FlightRouterState\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n * - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n  TEMPORARY = 'temporary',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   */\n  cache: CacheNode\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  renderedSearch: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n\n  /**\n   * The previous next-url that was used previous to a dynamic navigation.\n   */\n  previousNextUrl: string | null\n\n  debugInfo: Array<unknown> | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState =\n  | (Promise<AppRouterState> & { _debugInfo?: Array<unknown> })\n  | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n","/**\n * Check to see if a value is Thenable.\n *\n * @param promise the maybe-thenable value\n * @returns true if the value is thenable\n */\nexport function isThenable<T = unknown>(\n  promise: Promise<T> | T\n): promise is Promise<T> {\n  return (\n    promise !== null &&\n    typeof promise === 'object' &&\n    'then' in promise &&\n    typeof promise.then === 'function'\n  )\n}\n","import type { Dispatch } from 'react'\nimport React, { use, useMemo } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport type { AppRouterActionQueue } from './app-router-instance'\nimport type {\n  AppRouterState,\n  ReducerActions,\n  ReducerState,\n} from './router-reducer/router-reducer-types'\n\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch: Dispatch<ReducerActions> | null = null\n\nexport function dispatchAppRouterAction(action: ReducerActions) {\n  if (dispatch === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  dispatch(action)\n}\n\nconst __DEV__ = process.env.NODE_ENV !== 'production'\nconst promisesWithDebugInfo: WeakMap<\n  Promise<AppRouterState>,\n  Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n> = __DEV__ ? new WeakMap() : (null as any)\n\nexport function useActionQueue(\n  actionQueue: AppRouterActionQueue\n): AppRouterState {\n  const [state, setState] = React.useState<ReducerState>(actionQueue.state)\n\n  // Because of a known issue that requires to decode Flight streams inside the\n  // render phase, we have to be a bit clever and assign the dispatch method to\n  // a module-level variable upon initialization. The useState hook in this\n  // module only exists to synchronize state that lives outside of React.\n  // Ideally, what we'd do instead is pass the state as a prop to root.render;\n  // this is conceptually how we're modeling the app router state, despite the\n  // weird implementation details.\n  if (process.env.NODE_ENV !== 'production') {\n    const { useAppDevRenderingIndicator } =\n      require('../../next-devtools/userspace/use-app-dev-rendering-indicator') as typeof import('../../next-devtools/userspace/use-app-dev-rendering-indicator')\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const appDevRenderingIndicator = useAppDevRenderingIndicator()\n\n    dispatch = (action: ReducerActions) => {\n      appDevRenderingIndicator(() => {\n        actionQueue.dispatch(action, setState)\n      })\n    }\n  } else {\n    dispatch = (action: ReducerActions) =>\n      actionQueue.dispatch(action, setState)\n  }\n\n  // When navigating to a non-prefetched route, then App Router state will be\n  // blocked until the server responds. We need to transfer the `_debugInfo`\n  // from the underlying Flight response onto the top-level promise that is\n  // passed to React (via `use`) so that the latency is accurately represented\n  // in the React DevTools.\n  const stateWithDebugInfo = useMemo(() => {\n    if (!__DEV__) {\n      return state\n    }\n\n    if (isThenable(state)) {\n      // useMemo can't be used to cache a Promise since the memoized value is thrown\n      // away when we suspend. So we use a WeakMap to cache the Promise with debug info.\n      let promiseWithDebugInfo = promisesWithDebugInfo.get(state)\n      if (promiseWithDebugInfo === undefined) {\n        const debugInfo: Array<unknown> = []\n        promiseWithDebugInfo = Promise.resolve(state).then((asyncState) => {\n          if (asyncState.debugInfo !== null) {\n            debugInfo.push(...asyncState.debugInfo)\n          }\n          return asyncState\n        }) as Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n        promiseWithDebugInfo._debugInfo = debugInfo\n\n        promisesWithDebugInfo.set(state, promiseWithDebugInfo)\n      }\n\n      return promiseWithDebugInfo\n    }\n    return state\n  }, [state])\n\n  return isThenable(stateWithDebugInfo)\n    ? use(stateWithDebugInfo)\n    : stateWithDebugInfo\n}\n","import { startTransition } from 'react'\nimport { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types'\nimport { dispatchAppRouterAction } from './components/use-action-queue'\n\nexport async function callServer(actionId: string, actionArgs: any[]) {\n  return new Promise((resolve, reject) => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_SERVER_ACTION,\n        actionId,\n        actionArgs,\n        resolve,\n        reject,\n      })\n    })\n  })\n}\n","const basePath = process.env.__NEXT_ROUTER_BASEPATH || ''\nconst pathname = `${basePath}/__nextjs_source-map`\n\nexport const findSourceMapURL =\n  process.env.NODE_ENV === 'development'\n    ? function findSourceMapURL(filename: string): string | null {\n        if (filename === '') {\n          return null\n        }\n\n        if (\n          filename.startsWith(document.location.origin) &&\n          filename.includes('/_next/static')\n        ) {\n          // This is a request for a client chunk. This can only happen when\n          // using Turbopack. In this case, since we control how those source\n          // maps are generated, we can safely assume that the sourceMappingURL\n          // is relative to the filename, with an added `.map` extension. The\n          // browser can just request this file, and it gets served through the\n          // normal dev server, without the need to route this through\n          // the `/__nextjs_source-map` dev middleware.\n          return `${filename}.map`\n        }\n\n        const url = new URL(pathname, document.location.origin)\n        url.searchParams.set('filename', filename)\n\n        return url.href\n      }\n    : undefined\n","/**\n * Removes the trailing slash for a given route or page path. Preserves the\n * root page. Examples:\n *   - `/foo/bar/` -> `/foo/bar`\n *   - `/foo/bar` -> `/foo/bar`\n *   - `/` -> `/`\n */\nexport function removeTrailingSlash(route: string) {\n  return route.replace(/\\/$/, '') || '/'\n}\n","/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */\nexport function ensureLeadingSlash(path: string) {\n  return path.startsWith('/') ? path : `/${path}`\n}\n","import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'\nimport { isGroupSegment } from '../../segment'\n\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */\nexport function normalizeAppPath(route: string) {\n  return ensureLeadingSlash(\n    route.split('/').reduce((pathname, segment, index, segments) => {\n      // Empty segments are ignored.\n      if (!segment) {\n        return pathname\n      }\n\n      // Groups are ignored.\n      if (isGroupSegment(segment)) {\n        return pathname\n      }\n\n      // Parallel segments are ignored.\n      if (segment[0] === '@') {\n        return pathname\n      }\n\n      // The last segment (if it's a leaf) should be ignored.\n      if (\n        (segment === 'page' || segment === 'route') &&\n        index === segments.length - 1\n      ) {\n        return pathname\n      }\n\n      return `${pathname}/${segment}`\n    }, '')\n  )\n}\n\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */\nexport function normalizeRscURL(url: string) {\n  return url.replace(\n    /\\.rsc($|\\?)/,\n    // $1 ensures `?` is preserved\n    '$1'\n  )\n}\n","import { normalizeAppPath } from './app-paths'\n\n// order matters here, the first match will be used\nexport const INTERCEPTION_ROUTE_MARKERS = [\n  '(..)(..)',\n  '(.)',\n  '(..)',\n  '(...)',\n] as const\n\nexport function isInterceptionRouteAppPath(path: string): boolean {\n  // TODO-APP: add more serious validation\n  return (\n    path\n      .split('/')\n      .find((segment) =>\n        INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n      ) !== undefined\n  )\n}\n\ntype InterceptionRouteInformation = {\n  /**\n   * The intercepting route. This is the route that is being intercepted or the\n   * route that the user was coming from. This is matched by the Next-Url\n   * header.\n   */\n  interceptingRoute: string\n\n  /**\n   * The intercepted route. This is the route that is being intercepted or the\n   * route that the user is going to. This is matched by the request pathname.\n   */\n  interceptedRoute: string\n}\n\nexport function extractInterceptionRouteInformation(\n  path: string\n): InterceptionRouteInformation {\n  let interceptingRoute: string | undefined\n  let marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined\n  let interceptedRoute: string | undefined\n\n  for (const segment of path.split('/')) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n    if (marker) {\n      ;[interceptingRoute, interceptedRoute] = path.split(marker, 2)\n      break\n    }\n  }\n\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw new Error(\n      `Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`\n    )\n  }\n\n  interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n\n  switch (marker) {\n    case '(.)':\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === '/') {\n        interceptedRoute = `/${interceptedRoute}`\n      } else {\n        interceptedRoute = interceptingRoute + '/' + interceptedRoute\n      }\n      break\n    case '(..)':\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === '/') {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`\n        )\n      }\n      interceptedRoute = interceptingRoute\n        .split('/')\n        .slice(0, -1)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    case '(...)':\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = '/' + interceptedRoute\n      break\n    case '(..)(..)':\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n\n      const splitInterceptingRoute = interceptingRoute.split('/')\n      if (splitInterceptingRoute.length <= 2) {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`\n        )\n      }\n\n      interceptedRoute = splitInterceptingRoute\n        .slice(0, -2)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    default:\n      throw new Error('Invariant: unexpected marker')\n  }\n\n  return { interceptingRoute, interceptedRoute }\n}\n","import type { HtmlProps } from './html-context.shared-runtime'\nimport type { ComponentType, JSX } from 'react'\nimport type { DomainLocale } from '../../server/config'\nimport type { Env } from '@next/env'\nimport type { IncomingMessage, ServerResponse } from 'http'\nimport type { NextRouter } from './router/router'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { PreviewData } from '../../types'\nimport type { COMPILER_NAMES } from './constants'\nimport type fs from 'fs'\n\nexport type NextComponentType<\n  Context extends BaseContext = NextPageContext,\n  InitialProps = {},\n  Props = {},\n> = ComponentType<Props> & {\n  /**\n   * Used for initial page load data population. Data returned from `getInitialProps` is serialized when server rendered.\n   * Make sure to return plain `Object` without using `Date`, `Map`, `Set`.\n   * @param context Context of `page`\n   */\n  getInitialProps?(context: Context): InitialProps | Promise<InitialProps>\n}\n\nexport type DocumentType = NextComponentType<\n  DocumentContext,\n  DocumentInitialProps,\n  DocumentProps\n>\n\nexport type AppType<P = {}> = NextComponentType<\n  AppContextType,\n  P,\n  AppPropsType<any, P>\n>\n\nexport type AppTreeType = ComponentType<\n  AppInitialProps & { [name: string]: any }\n>\n\n/**\n * Web vitals provided to _app.reportWebVitals by Core Web Vitals plugin developed by Google Chrome team.\n * https://nextjs.org/blog/next-9-4#integrated-web-vitals-reporting\n */\nexport const WEB_VITALS = ['CLS', 'FCP', 'FID', 'INP', 'LCP', 'TTFB'] as const\nexport type NextWebVitalsMetric = {\n  id: string\n  startTime: number\n  value: number\n  attribution?: { [key: string]: unknown }\n} & (\n  | {\n      label: 'web-vital'\n      name: (typeof WEB_VITALS)[number]\n    }\n  | {\n      label: 'custom'\n      name:\n        | 'Next.js-hydration'\n        | 'Next.js-route-change-to-render'\n        | 'Next.js-render'\n    }\n)\n\nexport type Enhancer<C> = (Component: C) => C\n\nexport type ComponentsEnhancer =\n  | {\n      enhanceApp?: Enhancer<AppType>\n      enhanceComponent?: Enhancer<NextComponentType>\n    }\n  | Enhancer<NextComponentType>\n\nexport type RenderPageResult = {\n  html: string\n  head?: Array<JSX.Element | null>\n}\n\nexport type RenderPage = (\n  options?: ComponentsEnhancer\n) => DocumentInitialProps | Promise<DocumentInitialProps>\n\nexport type BaseContext = {\n  res?: ServerResponse\n  [k: string]: any\n}\n\nexport type NEXT_DATA = {\n  props: Record<string, any>\n  page: string\n  query: ParsedUrlQuery\n  buildId: string\n  assetPrefix?: string\n  nextExport?: boolean\n  autoExport?: boolean\n  isFallback?: boolean\n  isExperimentalCompile?: boolean\n  dynamicIds?: (string | number)[]\n  err?: Error & {\n    statusCode?: number\n    source?: typeof COMPILER_NAMES.server | typeof COMPILER_NAMES.edgeServer\n  }\n  gsp?: boolean\n  gssp?: boolean\n  customServer?: boolean\n  gip?: boolean\n  appGip?: boolean\n  locale?: string\n  locales?: readonly string[]\n  defaultLocale?: string\n  domainLocales?: readonly DomainLocale[]\n  scriptLoader?: any[]\n  isPreview?: boolean\n  notFoundSrcPage?: string\n}\n\n/**\n * `Next` context\n */\nexport interface NextPageContext {\n  /**\n   * Error object if encountered during rendering\n   */\n  err?: (Error & { statusCode?: number }) | null\n  /**\n   * `HTTP` request object.\n   */\n  req?: IncomingMessage\n  /**\n   * `HTTP` response object.\n   */\n  res?: ServerResponse\n  /**\n   * Path section of `URL`.\n   */\n  pathname: string\n  /**\n   * Query string section of `URL` parsed as an object.\n   */\n  query: ParsedUrlQuery\n  /**\n   * `String` of the actual path including query.\n   */\n  asPath?: string\n  /**\n   * The currently active locale\n   */\n  locale?: string\n  /**\n   * All configured locales\n   */\n  locales?: readonly string[]\n  /**\n   * The configured default locale\n   */\n  defaultLocale?: string\n  /**\n   * `Component` the tree of the App to use if needing to render separately\n   */\n  AppTree: AppTreeType\n}\n\nexport type AppContextType<Router extends NextRouter = NextRouter> = {\n  Component: NextComponentType<NextPageContext>\n  AppTree: AppTreeType\n  ctx: NextPageContext\n  router: Router\n}\n\nexport type AppInitialProps<PageProps = any> = {\n  pageProps: PageProps\n}\n\nexport type AppPropsType<\n  Router extends NextRouter = NextRouter,\n  PageProps = {},\n> = AppInitialProps<PageProps> & {\n  Component: NextComponentType<NextPageContext, any, any>\n  router: Router\n  __N_SSG?: boolean\n  __N_SSP?: boolean\n}\n\nexport type DocumentContext = NextPageContext & {\n  renderPage: RenderPage\n  defaultGetInitialProps(\n    ctx: DocumentContext,\n    options?: { nonce?: string }\n  ): Promise<DocumentInitialProps>\n}\n\nexport type DocumentInitialProps = RenderPageResult & {\n  styles?: React.ReactElement[] | Iterable<React.ReactNode> | JSX.Element\n}\n\nexport type DocumentProps = DocumentInitialProps & HtmlProps\n\n/**\n * Next `API` route request\n */\nexport interface NextApiRequest extends IncomingMessage {\n  /**\n   * Object of `query` values from url\n   */\n  query: Partial<{\n    [key: string]: string | string[]\n  }>\n  /**\n   * Object of `cookies` from header\n   */\n  cookies: Partial<{\n    [key: string]: string\n  }>\n\n  body: any\n\n  env: Env\n\n  draftMode?: boolean\n\n  preview?: boolean\n  /**\n   * Preview data set on the request, if any\n   * */\n  previewData?: PreviewData\n}\n\n/**\n * Send body of response\n */\ntype Send<T> = (body: T) => void\n\n/**\n * Next `API` route response\n */\nexport type NextApiResponse<Data = any> = ServerResponse & {\n  /**\n   * Send data `any` data in response\n   */\n  send: Send<Data>\n  /**\n   * Send data `json` data in response\n   */\n  json: Send<Data>\n  status: (statusCode: number) => NextApiResponse<Data>\n  redirect(url: string): NextApiResponse<Data>\n  redirect(status: number, url: string): NextApiResponse<Data>\n\n  /**\n   * Set draft mode\n   */\n  setDraftMode: (options: { enable: boolean }) => NextApiResponse<Data>\n\n  /**\n   * Set preview data for Next.js' prerender mode\n   */\n  setPreviewData: (\n    data: object | string,\n    options?: {\n      /**\n       * Specifies the number (in seconds) for the preview session to last for.\n       * The given number will be converted to an integer by rounding down.\n       * By default, no maximum age is set and the preview session finishes\n       * when the client shuts down (browser is closed).\n       */\n      maxAge?: number\n      /**\n       * Specifies the path for the preview session to work under. By default,\n       * the path is considered the \"default path\", i.e., any pages under \"/\".\n       */\n      path?: string\n    }\n  ) => NextApiResponse<Data>\n\n  /**\n   * Clear preview data for Next.js' prerender mode\n   */\n  clearPreviewData: (options?: { path?: string }) => NextApiResponse<Data>\n\n  /**\n   * Revalidate a specific page and regenerate it using On-Demand Incremental\n   * Static Regeneration.\n   * The path should be an actual path, not a rewritten path. E.g. for\n   * \"/blog/[slug]\" this should be \"/blog/post-1\".\n   * @link https://nextjs.org/docs/app/building-your-application/data-fetching/incremental-static-regeneration#on-demand-revalidation-with-revalidatepath\n   */\n  revalidate: (\n    urlPath: string,\n    opts?: {\n      unstable_onlyGenerated?: boolean\n    }\n  ) => Promise<void>\n}\n\n/**\n * Next `API` route handler\n */\nexport type NextApiHandler<T = any> = (\n  req: NextApiRequest,\n  res: NextApiResponse<T>\n) => unknown | Promise<unknown>\n\n/**\n * Utils\n */\nexport function execOnce<T extends (...args: any[]) => ReturnType<T>>(\n  fn: T\n): T {\n  let used = false\n  let result: ReturnType<T>\n\n  return ((...args: any[]) => {\n    if (!used) {\n      used = true\n      result = fn(...args)\n    }\n    return result\n  }) as T\n}\n\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/\nexport const isAbsoluteUrl = (url: string) => ABSOLUTE_URL_REGEX.test(url)\n\nexport function getLocationOrigin() {\n  const { protocol, hostname, port } = window.location\n  return `${protocol}//${hostname}${port ? ':' + port : ''}`\n}\n\nexport function getURL() {\n  const { href } = window.location\n  const origin = getLocationOrigin()\n  return href.substring(origin.length)\n}\n\nexport function getDisplayName<P>(Component: ComponentType<P>) {\n  return typeof Component === 'string'\n    ? Component\n    : Component.displayName || Component.name || 'Unknown'\n}\n\nexport function isResSent(res: ServerResponse) {\n  return res.finished || res.headersSent\n}\n\nexport function normalizeRepeatedSlashes(url: string) {\n  const urlParts = url.split('?')\n  const urlNoQuery = urlParts[0]\n\n  return (\n    urlNoQuery\n      // first we replace any non-encoded backslashes with forward\n      // then normalize repeated forward slashes\n      .replace(/\\\\/g, '/')\n      .replace(/\\/\\/+/g, '/') +\n    (urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '')\n  )\n}\n\nexport async function loadGetInitialProps<\n  C extends BaseContext,\n  IP = {},\n  P = {},\n>(App: NextComponentType<C, IP, P>, ctx: C): Promise<IP> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (App.prototype?.getInitialProps) {\n      const message = `\"${getDisplayName(\n        App\n      )}.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`\n      throw new Error(message)\n    }\n  }\n  // when called from _app `ctx` is nested in `ctx`\n  const res = ctx.res || (ctx.ctx && ctx.ctx.res)\n\n  if (!App.getInitialProps) {\n    if (ctx.ctx && ctx.Component) {\n      // @ts-ignore pageProps default\n      return {\n        pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx),\n      }\n    }\n    return {} as IP\n  }\n\n  const props = await App.getInitialProps(ctx)\n\n  if (res && isResSent(res)) {\n    return props\n  }\n\n  if (!props) {\n    const message = `\"${getDisplayName(\n      App\n    )}.getInitialProps()\" should resolve to an object. But found \"${props}\" instead.`\n    throw new Error(message)\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (Object.keys(props).length === 0 && !ctx.ctx) {\n      console.warn(\n        `${getDisplayName(\n          App\n        )} returned an empty object from \\`getInitialProps\\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`\n      )\n    }\n  }\n\n  return props\n}\n\nexport const SP = typeof performance !== 'undefined'\nexport const ST =\n  SP &&\n  (['mark', 'measure', 'getEntriesByName'] as const).every(\n    (method) => typeof performance[method] === 'function'\n  )\n\nexport class DecodeError extends Error {}\nexport class NormalizeError extends Error {}\nexport class PageNotFoundError extends Error {\n  code: string\n\n  constructor(page: string) {\n    super()\n    this.code = 'ENOENT'\n    this.name = 'PageNotFoundError'\n    this.message = `Cannot find module for page: ${page}`\n  }\n}\n\nexport class MissingStaticPage extends Error {\n  constructor(page: string, message: string) {\n    super()\n    this.message = `Failed to load static file for page: ${page} ${message}`\n  }\n}\n\nexport class MiddlewareNotFoundError extends Error {\n  code: string\n  constructor() {\n    super()\n    this.code = 'ENOENT'\n    this.message = `Cannot find the middleware module`\n  }\n}\n\nexport interface CacheFs {\n  existsSync: typeof fs.existsSync\n  readFile: typeof fs.promises.readFile\n  readFileSync: typeof fs.readFileSync\n  writeFile(f: string, d: any): Promise<void>\n  mkdir(dir: string): Promise<void | string>\n  stat(f: string): Promise<{ mtime: Date }>\n}\n\nexport function stringifyError(error: Error) {\n  return JSON.stringify({ message: error.message, stack: error.stack })\n}\n","import type { ParsedUrlQuery } from 'querystring'\n\nexport function searchParamsToUrlQuery(\n  searchParams: URLSearchParams\n): ParsedUrlQuery {\n  const query: ParsedUrlQuery = {}\n  for (const [key, value] of searchParams.entries()) {\n    const existing = query[key]\n    if (typeof existing === 'undefined') {\n      query[key] = value\n    } else if (Array.isArray(existing)) {\n      existing.push(value)\n    } else {\n      query[key] = [existing, value]\n    }\n  }\n  return query\n}\n\nfunction stringifyUrlQueryParam(param: unknown): string {\n  if (typeof param === 'string') {\n    return param\n  }\n\n  if (\n    (typeof param === 'number' && !isNaN(param)) ||\n    typeof param === 'boolean'\n  ) {\n    return String(param)\n  } else {\n    return ''\n  }\n}\n\nexport function urlQueryToSearchParams(query: ParsedUrlQuery): URLSearchParams {\n  const searchParams = new URLSearchParams()\n  for (const [key, value] of Object.entries(query)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        searchParams.append(key, stringifyUrlQueryParam(item))\n      }\n    } else {\n      searchParams.set(key, stringifyUrlQueryParam(value))\n    }\n  }\n  return searchParams\n}\n\nexport function assign(\n  target: URLSearchParams,\n  ...searchParamsList: URLSearchParams[]\n): URLSearchParams {\n  for (const searchParams of searchParamsList) {\n    for (const key of searchParams.keys()) {\n      target.delete(key)\n    }\n\n    for (const [key, value] of searchParams.entries()) {\n      target.append(key, value)\n    }\n  }\n\n  return target\n}\n","// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nimport type { UrlObject } from 'url'\nimport type { ParsedUrlQuery } from 'querystring'\nimport * as querystring from './querystring'\n\nconst slashedProtocols = /https?|ftp|gopher|file/\n\nexport function formatUrl(urlObj: UrlObject) {\n  let { auth, hostname } = urlObj\n  let protocol = urlObj.protocol || ''\n  let pathname = urlObj.pathname || ''\n  let hash = urlObj.hash || ''\n  let query = urlObj.query || ''\n  let host: string | false = false\n\n  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : ''\n\n  if (urlObj.host) {\n    host = auth + urlObj.host\n  } else if (hostname) {\n    host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname)\n    if (urlObj.port) {\n      host += ':' + urlObj.port\n    }\n  }\n\n  if (query && typeof query === 'object') {\n    query = String(querystring.urlQueryToSearchParams(query as ParsedUrlQuery))\n  }\n\n  let search = urlObj.search || (query && `?${query}`) || ''\n\n  if (protocol && !protocol.endsWith(':')) protocol += ':'\n\n  if (\n    urlObj.slashes ||\n    ((!protocol || slashedProtocols.test(protocol)) && host !== false)\n  ) {\n    host = '//' + (host || '')\n    if (pathname && pathname[0] !== '/') pathname = '/' + pathname\n  } else if (!host) {\n    host = ''\n  }\n\n  if (hash && hash[0] !== '#') hash = '#' + hash\n  if (search && search[0] !== '?') search = '?' + search\n\n  pathname = pathname.replace(/[?#]/g, encodeURIComponent)\n  search = search.replace('#', '%23')\n\n  return `${protocol}${host}${pathname}${search}${hash}`\n}\n\nexport const urlObjectKeys = [\n  'auth',\n  'hash',\n  'host',\n  'hostname',\n  'href',\n  'path',\n  'pathname',\n  'port',\n  'protocol',\n  'query',\n  'search',\n  'slashes',\n]\n\nexport function formatWithValidation(url: UrlObject): string {\n  if (process.env.NODE_ENV === 'development') {\n    if (url !== null && typeof url === 'object') {\n      Object.keys(url).forEach((key) => {\n        if (!urlObjectKeys.includes(key)) {\n          console.warn(\n            `Unknown key passed via urlObject into url.format: ${key}`\n          )\n        }\n      })\n    }\n  }\n\n  return formatUrl(url)\n}\n","/**\n * Given a path this function will find the pathname, query and hash and return\n * them. This is useful to parse full paths on the client side.\n * @param path A path to parse e.g. /foo/bar?id=1#hash\n */\nexport function parsePath(path: string) {\n  const hashIndex = path.indexOf('#')\n  const queryIndex = path.indexOf('?')\n  const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex)\n\n  if (hasQuery || hashIndex > -1) {\n    return {\n      pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n      query: hasQuery\n        ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined)\n        : '',\n      hash: hashIndex > -1 ? path.slice(hashIndex) : '',\n    }\n  }\n\n  return { pathname: path, query: '', hash: '' }\n}\n","import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { parsePath } from '../shared/lib/router/utils/parse-path'\n\n/**\n * Normalizes the trailing slash of a path according to the `trailingSlash` option\n * in `next.config.js`.\n */\nexport const normalizePathTrailingSlash = (path: string) => {\n  if (!path.startsWith('/') || process.env.__NEXT_MANUAL_TRAILING_SLASH) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  if (process.env.__NEXT_TRAILING_SLASH) {\n    if (/\\.[^/]+\\/?$/.test(pathname)) {\n      return `${removeTrailingSlash(pathname)}${query}${hash}`\n    } else if (pathname.endsWith('/')) {\n      return `${pathname}${query}${hash}`\n    } else {\n      return `${pathname}/${query}${hash}`\n    }\n  }\n\n  return `${removeTrailingSlash(pathname)}${query}${hash}`\n}\n","import { parsePath } from './parse-path'\n\n/**\n * Checks if a given path starts with a given prefix. It ensures it matches\n * exactly without containing extra chars. e.g. prefix /docs should replace\n * for /docs, /docs/, /docs/a but not /docsss\n * @param path The path to check.\n * @param prefix The prefix to check against.\n */\nexport function pathHasPrefix(path: string, prefix: string) {\n  if (typeof path !== 'string') {\n    return false\n  }\n\n  const { pathname } = parsePath(path)\n  return pathname === prefix || pathname.startsWith(prefix + '/')\n}\n","import { pathHasPrefix } from '../shared/lib/router/utils/path-has-prefix'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function hasBasePath(path: string): boolean {\n  return pathHasPrefix(path, basePath)\n}\n","import { parsePath } from './parse-path'\n\n/**\n * Adds the provided prefix to the given path. It first ensures that the path\n * is indeed starting with a slash.\n */\nexport function addPathPrefix(path: string, prefix?: string) {\n  if (!path.startsWith('/') || !prefix) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  return `${prefix}${pathname}${query}${hash}`\n}\n","import { addPathPrefix } from '../shared/lib/router/utils/add-path-prefix'\nimport { normalizePathTrailingSlash } from './normalize-trailing-slash'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function addBasePath(path: string, required?: boolean): string {\n  return normalizePathTrailingSlash(\n    process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required\n      ? path\n      : addPathPrefix(path, basePath)\n  )\n}\n","import { isAbsoluteUrl, getLocationOrigin } from '../../utils'\nimport { hasBasePath } from '../../../../client/has-base-path'\n\n/**\n * Detects whether a given url is routable by the Next.js router (browser only).\n */\nexport function isLocalURL(url: string): boolean {\n  // prevent a hydration mismatch on href for url with anchor refs\n  if (!isAbsoluteUrl(url)) return true\n  try {\n    // absolute urls can be local if they are on the same origin\n    const locationOrigin = getLocationOrigin()\n    const resolved = new URL(url, locationOrigin)\n    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname)\n  } catch (_) {\n    return false\n  }\n}\n","let warnOnce = (_: string) => {}\nif (process.env.NODE_ENV !== 'production') {\n  const warnings = new Set<string>()\n  warnOnce = (msg: string) => {\n    if (!warnings.has(msg)) {\n      console.warn(msg)\n    }\n    warnings.add(msg)\n  }\n}\n\nexport { warnOnce }\n"],"names":["ACTION_HMR_REFRESH","ACTION_NAVIGATE","ACTION_REFRESH","ACTION_RESTORE","ACTION_SERVER_ACTION","ACTION_SERVER_PATCH","PrefetchKind","isThenable","promise","then","dispatchAppRouterAction","useActionQueue","dispatch","action","Error","__DEV__","process","env","NODE_ENV","promisesWithDebugInfo","WeakMap","actionQueue","state","setState","React","useState","useAppDevRenderingIndicator","require","appDevRenderingIndicator","stateWithDebugInfo","useMemo","promiseWithDebugInfo","get","undefined","debugInfo","Promise","resolve","asyncState","push","_debugInfo","set","use","callServer","actionId","actionArgs","reject","startTransition","type","findSourceMapURL","basePath","__NEXT_ROUTER_BASEPATH","pathname","filename","startsWith","document","location","origin","includes","url","URL","searchParams","href","removeTrailingSlash","route","replace","ensureLeadingSlash","path","normalizeAppPath","normalizeRscURL","split","reduce","segment","index","segments","isGroupSegment","length","INTERCEPTION_ROUTE_MARKERS","extractInterceptionRouteInformation","isInterceptionRouteAppPath","find","m","interceptingRoute","marker","interceptedRoute","slice","concat","join","splitInterceptingRoute","DecodeError","MiddlewareNotFoundError","MissingStaticPage","NormalizeError","PageNotFoundError","SP","ST","WEB_VITALS","execOnce","getDisplayName","getLocationOrigin","getURL","isAbsoluteUrl","isResSent","loadGetInitialProps","normalizeRepeatedSlashes","stringifyError","fn","used","result","args","ABSOLUTE_URL_REGEX","test","protocol","hostname","port","window","substring","Component","displayName","name","res","finished","headersSent","urlParts","urlNoQuery","App","ctx","prototype","getInitialProps","message","pageProps","props","Object","keys","console","warn","performance","every","method","constructor","page","code","error","JSON","stringify","stack","assign","searchParamsToUrlQuery","urlQueryToSearchParams","query","key","value","entries","existing","Array","isArray","stringifyUrlQueryParam","param","isNaN","String","URLSearchParams","item","append","target","searchParamsList","delete","formatUrl","formatWithValidation","urlObjectKeys","slashedProtocols","urlObj","auth","hash","host","encodeURIComponent","indexOf","querystring","search","endsWith","slashes","forEach","parsePath","hashIndex","queryIndex","hasQuery","normalizePathTrailingSlash","__NEXT_MANUAL_TRAILING_SLASH","__NEXT_TRAILING_SLASH","pathHasPrefix","prefix","hasBasePath","addPathPrefix","addBasePath","required","__NEXT_MANUAL_CLIENT_BASE_PATH","isLocalURL","locationOrigin","resolved","_","warnOnce","warnings","Set","msg","has","add"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]}