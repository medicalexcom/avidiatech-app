{"version":3,"sources":["../../../node_modules/%40clerk/shared/dist/runtime/telemetry.mjs","../../../node_modules/%40clerk/nextjs/dist/esm/server/clerkClient.js","../../../node_modules/%40clerk/nextjs/dist/esm/server/middleware-storage.js","../../../node_modules/%40clerk/nextjs/dist/esm/server/createClerkClient.js","../../../node_modules/%40clerk/shared/src/telemetry/throttler.ts","../../../node_modules/%40clerk/nextjs/src/server/clerkClient.ts","../../../node_modules/%40clerk/backend/dist/index.mjs","../../../node_modules/%40clerk/nextjs/src/server/createClerkClient.ts","../../../node_modules/%40clerk/shared/src/telemetry/collector.ts","../../../node_modules/%40clerk/shared/src/telemetry/events/component-mounted.ts","../../../node_modules/%40clerk/shared/src/telemetry/events/method-called.ts","../../../node_modules/%40clerk/shared/src/telemetry/events/framework-metadata.ts","../../../node_modules/%40clerk/shared/src/telemetry/events/theme-usage.ts","../../../src/lib/billing.ts","../../../src/lib/errors.ts","../../../src/lib/owners.ts","../../../src/lib/clerk-utils.ts"],"sourcesContent":["import \"./constants-ByUssRbE.mjs\";\nimport \"./isomorphicAtob-DybBXGFR.mjs\";\nimport \"./isomorphicBtoa-Dr7WubZv.mjs\";\nimport \"./keys-YNv6yjKk.mjs\";\nimport \"./underscore-DjQrhefX.mjs\";\nimport { EVENT_SAMPLING_RATE, EVENT_THEME_USAGE, TelemetryCollector, eventComponentMounted, eventFrameworkMetadata, eventMethodCalled, eventPrebuiltComponentMounted, eventPrebuiltComponentOpened, eventThemeUsage } from \"./telemetry-wqMDWlvR.mjs\";\n\nexport { EVENT_SAMPLING_RATE, EVENT_THEME_USAGE, TelemetryCollector, eventComponentMounted, eventFrameworkMetadata, eventMethodCalled, eventPrebuiltComponentMounted, eventPrebuiltComponentOpened, eventThemeUsage };","import \"../chunk-BUSYA2B4.js\";\nimport { constants } from \"@clerk/backend/internal\";\nimport { buildRequestLike, isPrerenderingBailout } from \"../app-router/server/utils\";\nimport { createClerkClientWithOptions } from \"./createClerkClient\";\nimport { getHeader } from \"./headers-utils\";\nimport { clerkMiddlewareRequestDataStorage } from \"./middleware-storage\";\nimport { decryptClerkRequestData } from \"./utils\";\nconst clerkClient = async () => {\n  var _a, _b;\n  let requestData;\n  try {\n    const request = await buildRequestLike();\n    const encryptedRequestData = getHeader(request, constants.Headers.ClerkRequestData);\n    requestData = decryptClerkRequestData(encryptedRequestData);\n  } catch (err) {\n    if (err && isPrerenderingBailout(err)) {\n      throw err;\n    }\n  }\n  const options = (_b = (_a = clerkMiddlewareRequestDataStorage.getStore()) == null ? void 0 : _a.get(\"requestData\")) != null ? _b : requestData;\n  if ((options == null ? void 0 : options.secretKey) || (options == null ? void 0 : options.publishableKey)) {\n    return createClerkClientWithOptions(options);\n  }\n  return createClerkClientWithOptions({});\n};\nexport {\n  clerkClient\n};\n//# sourceMappingURL=clerkClient.js.map","import \"../chunk-BUSYA2B4.js\";\nimport { AsyncLocalStorage } from \"node:async_hooks\";\nconst clerkMiddlewareRequestDataStore = /* @__PURE__ */ new Map();\nconst clerkMiddlewareRequestDataStorage = new AsyncLocalStorage();\nexport {\n  clerkMiddlewareRequestDataStorage,\n  clerkMiddlewareRequestDataStore\n};\n//# sourceMappingURL=middleware-storage.js.map","import \"../chunk-BUSYA2B4.js\";\nimport { createClerkClient } from \"@clerk/backend\";\nimport {\n  API_URL,\n  API_VERSION,\n  DOMAIN,\n  IS_SATELLITE,\n  MACHINE_SECRET_KEY,\n  PROXY_URL,\n  PUBLISHABLE_KEY,\n  SDK_METADATA,\n  SECRET_KEY,\n  TELEMETRY_DEBUG,\n  TELEMETRY_DISABLED\n} from \"./constants\";\nconst clerkClientDefaultOptions = {\n  secretKey: SECRET_KEY,\n  publishableKey: PUBLISHABLE_KEY,\n  apiUrl: API_URL,\n  apiVersion: API_VERSION,\n  userAgent: `${\"@clerk/nextjs\"}@${\"6.36.2\"}`,\n  proxyUrl: PROXY_URL,\n  domain: DOMAIN,\n  isSatellite: IS_SATELLITE,\n  machineSecretKey: MACHINE_SECRET_KEY,\n  sdkMetadata: SDK_METADATA,\n  telemetry: {\n    disabled: TELEMETRY_DISABLED,\n    debug: TELEMETRY_DEBUG\n  }\n};\nconst createClerkClientWithOptions = (options) => createClerkClient({ ...clerkClientDefaultOptions, ...options });\nexport {\n  createClerkClientWithOptions\n};\n//# sourceMappingURL=createClerkClient.js.map","import type { TelemetryEvent } from '../types';\n\ntype TtlInMilliseconds = number;\n\nconst DEFAULT_CACHE_TTL_MS = 86400000; // 24 hours\n\n/**\n * Interface for cache storage used by the telemetry throttler.\n * Implementations can use localStorage, in-memory storage, or any other storage mechanism.\n */\nexport interface ThrottlerCache {\n  getItem(key: string): TtlInMilliseconds | undefined;\n  setItem(key: string, value: TtlInMilliseconds): void;\n  removeItem(key: string): void;\n}\n\n/**\n * Manages throttling for telemetry events using a configurable cache implementation\n * to mitigate event flooding in frequently executed code paths.\n */\nexport class TelemetryEventThrottler {\n  #cache: ThrottlerCache;\n  #cacheTtl = DEFAULT_CACHE_TTL_MS;\n\n  constructor(cache: ThrottlerCache) {\n    this.#cache = cache;\n  }\n\n  isEventThrottled(payload: TelemetryEvent): boolean {\n    const now = Date.now();\n    const key = this.#generateKey(payload);\n    const entry = this.#cache.getItem(key);\n\n    if (!entry) {\n      this.#cache.setItem(key, now);\n      return false;\n    }\n\n    const shouldInvalidate = now - entry > this.#cacheTtl;\n    if (shouldInvalidate) {\n      this.#cache.setItem(key, now);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Generates a consistent unique key for telemetry events by sorting payload properties.\n   * This ensures that payloads with identical content in different orders produce the same key.\n   */\n  #generateKey(event: TelemetryEvent): string {\n    const { sk: _sk, pk: _pk, payload, ...rest } = event;\n\n    const sanitizedEvent: Omit<TelemetryEvent, 'sk' | 'pk' | 'payload'> & TelemetryEvent['payload'] = {\n      ...payload,\n      ...rest,\n    };\n\n    return JSON.stringify(\n      Object.keys({\n        ...payload,\n        ...rest,\n      })\n        .sort()\n        .map(key => sanitizedEvent[key]),\n    );\n  }\n}\n\n/**\n * LocalStorage-based cache implementation for browser environments.\n */\nexport class LocalStorageThrottlerCache implements ThrottlerCache {\n  #storageKey = 'clerk_telemetry_throttler';\n\n  getItem(key: string): TtlInMilliseconds | undefined {\n    return this.#getCache()[key];\n  }\n\n  setItem(key: string, value: TtlInMilliseconds): void {\n    try {\n      const cache = this.#getCache();\n      cache[key] = value;\n      localStorage.setItem(this.#storageKey, JSON.stringify(cache));\n    } catch (err: unknown) {\n      const isQuotaExceededError =\n        err instanceof DOMException &&\n        // Check error names for different browsers\n        (err.name === 'QuotaExceededError' || err.name === 'NS_ERROR_DOM_QUOTA_REACHED');\n\n      if (isQuotaExceededError && localStorage.length > 0) {\n        // Clear our cache if quota exceeded\n        localStorage.removeItem(this.#storageKey);\n      }\n    }\n  }\n\n  removeItem(key: string): void {\n    try {\n      const cache = this.#getCache();\n      delete cache[key];\n      localStorage.setItem(this.#storageKey, JSON.stringify(cache));\n    } catch {\n      // Silently fail if we can't remove\n    }\n  }\n\n  #getCache(): Record<string, TtlInMilliseconds> {\n    try {\n      const cacheString = localStorage.getItem(this.#storageKey);\n      if (!cacheString) {\n        return {};\n      }\n      return JSON.parse(cacheString);\n    } catch {\n      return {};\n    }\n  }\n\n  static isSupported(): boolean {\n    return typeof window !== 'undefined' && !!window.localStorage;\n  }\n}\n\n/**\n * In-memory cache implementation for non-browser environments (e.g., React Native).\n */\nexport class InMemoryThrottlerCache implements ThrottlerCache {\n  #cache: Map<string, TtlInMilliseconds> = new Map();\n  #maxSize = 10000; // Defensive limit to prevent memory issues\n\n  getItem(key: string): TtlInMilliseconds | undefined {\n    // Defensive: clear cache if it gets too large\n    if (this.#cache.size > this.#maxSize) {\n      this.#cache.clear();\n      return undefined;\n    }\n\n    return this.#cache.get(key);\n  }\n\n  setItem(key: string, value: TtlInMilliseconds): void {\n    this.#cache.set(key, value);\n  }\n\n  removeItem(key: string): void {\n    this.#cache.delete(key);\n  }\n}\n","import { constants } from '@clerk/backend/internal';\n\nimport { buildRequestLike, isPrerenderingBailout } from '../app-router/server/utils';\nimport { createClerkClientWithOptions } from './createClerkClient';\nimport { getHeader } from './headers-utils';\nimport { clerkMiddlewareRequestDataStorage } from './middleware-storage';\nimport { decryptClerkRequestData } from './utils';\n\n/**\n * Constructs a BAPI client that accesses request data within the runtime.\n * Necessary if middleware dynamic keys are used.\n */\nconst clerkClient = async () => {\n  let requestData;\n\n  try {\n    const request = await buildRequestLike();\n    const encryptedRequestData = getHeader(request, constants.Headers.ClerkRequestData);\n    requestData = decryptClerkRequestData(encryptedRequestData);\n  } catch (err) {\n    if (err && isPrerenderingBailout(err)) {\n      throw err;\n    }\n  }\n\n  // Fallbacks between options from middleware runtime and `NextRequest` from application server\n  const options = clerkMiddlewareRequestDataStorage.getStore()?.get('requestData') ?? requestData;\n  if (options?.secretKey || options?.publishableKey) {\n    return createClerkClientWithOptions(options);\n  }\n\n  return createClerkClientWithOptions({});\n};\n\nexport { clerkClient };\n","import {\n  createAuthenticateRequest,\n  createBackendApiClient,\n  verifyToken\n} from \"./chunk-5ZC5VXBY.mjs\";\nimport \"./chunk-YBVFDYDR.mjs\";\nimport {\n  withLegacyReturn\n} from \"./chunk-P263NW7Z.mjs\";\nimport \"./chunk-7X3P2E3X.mjs\";\nimport \"./chunk-TCIXZLLW.mjs\";\nimport \"./chunk-RPS7XK5K.mjs\";\n\n// src/index.ts\nimport { TelemetryCollector } from \"@clerk/shared/telemetry\";\nvar verifyToken2 = withLegacyReturn(verifyToken);\nfunction createClerkClient(options) {\n  const opts = { ...options };\n  const apiClient = createBackendApiClient(opts);\n  const requestState = createAuthenticateRequest({ options: opts, apiClient });\n  const telemetry = new TelemetryCollector({\n    publishableKey: opts.publishableKey,\n    secretKey: opts.secretKey,\n    samplingRate: 0.1,\n    ...opts.sdkMetadata ? { sdk: opts.sdkMetadata.name, sdkVersion: opts.sdkMetadata.version } : {},\n    ...opts.telemetry || {}\n  });\n  return {\n    ...apiClient,\n    ...requestState,\n    telemetry\n  };\n}\nexport {\n  createClerkClient,\n  verifyToken2 as verifyToken\n};\n//# sourceMappingURL=index.mjs.map","import { createClerkClient } from '@clerk/backend';\n\nimport {\n  API_URL,\n  API_VERSION,\n  DOMAIN,\n  IS_SATELLITE,\n  MACHINE_SECRET_KEY,\n  PROXY_URL,\n  PUBLISHABLE_KEY,\n  SDK_METADATA,\n  SECRET_KEY,\n  TELEMETRY_DEBUG,\n  TELEMETRY_DISABLED,\n} from './constants';\n\nconst clerkClientDefaultOptions = {\n  secretKey: SECRET_KEY,\n  publishableKey: PUBLISHABLE_KEY,\n  apiUrl: API_URL,\n  apiVersion: API_VERSION,\n  userAgent: `${PACKAGE_NAME}@${PACKAGE_VERSION}`,\n  proxyUrl: PROXY_URL,\n  domain: DOMAIN,\n  isSatellite: IS_SATELLITE,\n  machineSecretKey: MACHINE_SECRET_KEY,\n  sdkMetadata: SDK_METADATA,\n  telemetry: {\n    disabled: TELEMETRY_DISABLED,\n    debug: TELEMETRY_DEBUG,\n  },\n};\n\nexport const createClerkClientWithOptions: typeof createClerkClient = options =>\n  createClerkClient({ ...clerkClientDefaultOptions, ...options });\n","/**\n * The `TelemetryCollector` class handles collection of telemetry events from Clerk SDKs. Telemetry is opt-out and can be disabled by setting a CLERK_TELEMETRY_DISABLED environment variable.\n * The `ClerkProvider` also accepts a `telemetry` prop that will be passed to the collector during initialization:.\n *\n * ```jsx\n * <ClerkProvider telemetry={false}>\n *    ...\n * </ClerkProvider>\n * ```\n *\n * For more information, please see the telemetry documentation page: https://clerk.com/docs/telemetry.\n */\nimport { parsePublishableKey } from '../keys';\nimport type {\n  InstanceType,\n  SDKMetadata,\n  TelemetryCollector as TelemetryCollectorInterface,\n  TelemetryEvent,\n  TelemetryEventRaw,\n  TelemetryLogEntry,\n} from '../types';\nimport { isTruthy } from '../underscore';\nimport { InMemoryThrottlerCache, LocalStorageThrottlerCache, TelemetryEventThrottler } from './throttler';\nimport type { TelemetryCollectorOptions } from './types';\n\n/**\n * Local interface for window.Clerk to avoid global type pollution.\n * This is only used within this module and doesn't affect other packages.\n */\ninterface WindowWithClerk extends Window {\n  Clerk?: {\n    constructor?: {\n      sdkMetadata?: SDKMetadata;\n    };\n  };\n}\n\n/**\n * Type guard to check if window.Clerk exists and has the expected structure.\n */\nfunction isWindowClerkWithMetadata(clerk: unknown): clerk is { constructor: { sdkMetadata?: SDKMetadata } } {\n  return (\n    typeof clerk === 'object' && clerk !== null && 'constructor' in clerk && typeof clerk.constructor === 'function'\n  );\n}\n\ntype TelemetryCollectorConfig = Pick<\n  TelemetryCollectorOptions,\n  'samplingRate' | 'disabled' | 'debug' | 'maxBufferSize' | 'perEventSampling'\n> & {\n  endpoint: string;\n};\n\ntype TelemetryMetadata = Required<\n  Pick<TelemetryCollectorOptions, 'clerkVersion' | 'sdk' | 'sdkVersion' | 'publishableKey' | 'secretKey'>\n> & {\n  /**\n   * The instance type, derived from the provided publishableKey.\n   */\n  instanceType: InstanceType;\n};\n\n/**\n * Structure of log data sent to the telemetry endpoint.\n */\ntype TelemetryLogData = {\n  /** Service that generated the log. */\n  sdk: string;\n  /** The version of the SDK where the event originated from. */\n  sdkv: string;\n  /** The version of Clerk where the event originated from. */\n  cv: string;\n  /** Log level (info, warn, error, debug, etc.). */\n  lvl: TelemetryLogEntry['level'];\n  /** Log message. */\n  msg: string;\n  /** Instance ID - optional. */\n  iid?: string;\n  /** Timestamp when log was generated. */\n  ts: string;\n  /** Primary key. */\n  pk: string | null;\n  /** Additional payload for the log. */\n  payload: Record<string, unknown> | null;\n};\n\ntype TelemetryBufferItem = { kind: 'event'; value: TelemetryEvent } | { kind: 'log'; value: TelemetryLogData };\n\n// Accepted log levels for runtime validation\nconst VALID_LOG_LEVELS = new Set<string>(['error', 'warn', 'info', 'debug', 'trace']);\n\nconst DEFAULT_CONFIG: Partial<TelemetryCollectorConfig> = {\n  samplingRate: 1,\n  maxBufferSize: 5,\n  // Production endpoint: https://clerk-telemetry.com\n  // Staging endpoint: https://staging.clerk-telemetry.com\n  // Local: http://localhost:8787\n  endpoint: 'https://clerk-telemetry.com',\n};\n\nexport class TelemetryCollector implements TelemetryCollectorInterface {\n  #config: Required<TelemetryCollectorConfig>;\n  #eventThrottler: TelemetryEventThrottler;\n  #metadata: TelemetryMetadata = {} as TelemetryMetadata;\n  #buffer: TelemetryBufferItem[] = [];\n  #pendingFlush: number | ReturnType<typeof setTimeout> | null = null;\n\n  constructor(options: TelemetryCollectorOptions) {\n    this.#config = {\n      maxBufferSize: options.maxBufferSize ?? DEFAULT_CONFIG.maxBufferSize,\n      samplingRate: options.samplingRate ?? DEFAULT_CONFIG.samplingRate,\n      perEventSampling: options.perEventSampling ?? true,\n      disabled: options.disabled ?? false,\n      debug: options.debug ?? false,\n      endpoint: DEFAULT_CONFIG.endpoint,\n    } as Required<TelemetryCollectorConfig>;\n\n    if (!options.clerkVersion && typeof window === 'undefined') {\n      // N/A in a server environment\n      this.#metadata.clerkVersion = '';\n    } else {\n      this.#metadata.clerkVersion = options.clerkVersion ?? '';\n    }\n\n    // We will try to grab the SDK data lazily when an event is triggered, so it should always be defined once the event is sent.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.#metadata.sdk = options.sdk!;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.#metadata.sdkVersion = options.sdkVersion!;\n\n    this.#metadata.publishableKey = options.publishableKey ?? '';\n\n    const parsedKey = parsePublishableKey(options.publishableKey);\n    if (parsedKey) {\n      this.#metadata.instanceType = parsedKey.instanceType;\n    }\n\n    if (options.secretKey) {\n      // Only send the first 16 characters of the secret key to to avoid sending the full key. We can still query against the partial key.\n      this.#metadata.secretKey = options.secretKey.substring(0, 16);\n    }\n\n    // Use LocalStorage cache in browsers where it's supported, otherwise fall back to in-memory cache\n    const cache = LocalStorageThrottlerCache.isSupported()\n      ? new LocalStorageThrottlerCache()\n      : new InMemoryThrottlerCache();\n    this.#eventThrottler = new TelemetryEventThrottler(cache);\n  }\n\n  get isEnabled(): boolean {\n    if (this.#metadata.instanceType !== 'development') {\n      return false;\n    }\n\n    // In browser or client environments, we most likely pass the disabled option to the collector, but in environments\n    // where environment variables are available we also check for `CLERK_TELEMETRY_DISABLED`.\n    if (\n      this.#config.disabled ||\n      (typeof process !== 'undefined' && process.env && isTruthy(process.env.CLERK_TELEMETRY_DISABLED))\n    ) {\n      return false;\n    }\n\n    // navigator.webdriver is a property generally set by headless browsers that are running in an automated testing environment.\n    // Data from these environments is not meaningful for us and has the potential to produce a large volume of events, so we disable\n    // collection in this case. (ref: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/webdriver)\n    if (typeof window !== 'undefined' && !!window?.navigator?.webdriver) {\n      return false;\n    }\n\n    return true;\n  }\n\n  get isDebug(): boolean {\n    return (\n      this.#config.debug ||\n      (typeof process !== 'undefined' && process.env && isTruthy(process.env.CLERK_TELEMETRY_DEBUG))\n    );\n  }\n\n  record(event: TelemetryEventRaw): void {\n    try {\n      const preparedPayload = this.#preparePayload(event.event, event.payload);\n\n      this.#logEvent(preparedPayload.event, preparedPayload);\n\n      if (!this.#shouldRecord(preparedPayload, event.eventSamplingRate)) {\n        return;\n      }\n\n      this.#buffer.push({ kind: 'event', value: preparedPayload });\n\n      this.#scheduleFlush();\n    } catch (error) {\n      console.error('[clerk/telemetry] Error recording telemetry event', error);\n    }\n  }\n\n  /**\n   * Records a telemetry log entry if logging is enabled and not in debug mode.\n   *\n   * @param entry - The telemetry log entry to record.\n   */\n  recordLog(entry: TelemetryLogEntry): void {\n    try {\n      if (!this.#shouldRecordLog(entry)) {\n        return;\n      }\n\n      const levelIsValid = typeof entry?.level === 'string' && VALID_LOG_LEVELS.has(entry.level);\n      const messageIsValid = typeof entry?.message === 'string' && entry.message.trim().length > 0;\n\n      let normalizedTimestamp: Date | null = null;\n      const timestampInput: unknown = (entry as unknown as { timestamp?: unknown })?.timestamp;\n      if (typeof timestampInput === 'number' || typeof timestampInput === 'string') {\n        const candidate = new Date(timestampInput);\n        if (!Number.isNaN(candidate.getTime())) {\n          normalizedTimestamp = candidate;\n        }\n      }\n\n      if (!levelIsValid || !messageIsValid || normalizedTimestamp === null) {\n        if (this.isDebug && typeof console !== 'undefined') {\n          console.warn('[clerk/telemetry] Dropping invalid telemetry log entry', {\n            levelIsValid,\n            messageIsValid,\n            timestampIsValid: normalizedTimestamp !== null,\n          });\n        }\n        return;\n      }\n\n      const sdkMetadata = this.#getSDKMetadata();\n\n      const logData: TelemetryLogData = {\n        sdk: sdkMetadata.name,\n        sdkv: sdkMetadata.version,\n        cv: this.#metadata.clerkVersion ?? '',\n        lvl: entry.level,\n        msg: entry.message,\n        ts: normalizedTimestamp.toISOString(),\n        pk: this.#metadata.publishableKey || null,\n        payload: this.#sanitizeContext(entry.context),\n      };\n\n      this.#buffer.push({ kind: 'log', value: logData });\n\n      this.#scheduleFlush();\n    } catch (error) {\n      console.error('[clerk/telemetry] Error recording telemetry log entry', error);\n    }\n  }\n\n  #shouldRecord(preparedPayload: TelemetryEvent, eventSamplingRate?: number) {\n    return this.isEnabled && !this.isDebug && this.#shouldBeSampled(preparedPayload, eventSamplingRate);\n  }\n\n  #shouldRecordLog(_entry: TelemetryLogEntry): boolean {\n    // Always allow logs from debug logger to be sent. Debug logger itself is already gated elsewhere.\n    return true;\n  }\n\n  #shouldBeSampled(preparedPayload: TelemetryEvent, eventSamplingRate?: number) {\n    const randomSeed = Math.random();\n\n    const toBeSampled =\n      randomSeed <= this.#config.samplingRate &&\n      (this.#config.perEventSampling === false ||\n        typeof eventSamplingRate === 'undefined' ||\n        randomSeed <= eventSamplingRate);\n\n    if (!toBeSampled) {\n      return false;\n    }\n\n    return !this.#eventThrottler.isEventThrottled(preparedPayload);\n  }\n\n  #scheduleFlush(): void {\n    // On the server, we want to flush immediately as we have less guarantees about the lifecycle of the process\n    if (typeof window === 'undefined') {\n      this.#flush();\n      return;\n    }\n    const isBufferFull = this.#buffer.length >= this.#config.maxBufferSize;\n    if (isBufferFull) {\n      // If the buffer is full, flush immediately to make sure we minimize the chance of event loss.\n      // Cancel any pending flushes as we're going to flush immediately\n      if (this.#pendingFlush) {\n        if (typeof cancelIdleCallback !== 'undefined') {\n          cancelIdleCallback(Number(this.#pendingFlush));\n        } else {\n          clearTimeout(Number(this.#pendingFlush));\n        }\n      }\n      this.#flush();\n      return;\n    }\n\n    // If we have a pending flush, do nothing\n    if (this.#pendingFlush) {\n      return;\n    }\n\n    if ('requestIdleCallback' in window) {\n      this.#pendingFlush = requestIdleCallback(() => {\n        this.#flush();\n        this.#pendingFlush = null;\n      });\n    } else {\n      // This is not an ideal solution, but it at least waits until the next tick\n      this.#pendingFlush = setTimeout(() => {\n        this.#flush();\n        this.#pendingFlush = null;\n      }, 0);\n    }\n  }\n\n  #flush(): void {\n    // Capture the current buffer and clear it immediately to avoid closure references\n    const itemsToSend = [...this.#buffer];\n    this.#buffer = [];\n\n    this.#pendingFlush = null;\n\n    if (itemsToSend.length === 0) {\n      return;\n    }\n\n    const eventsToSend = itemsToSend\n      .filter(item => item.kind === 'event')\n      .map(item => (item as { kind: 'event'; value: TelemetryEvent }).value);\n\n    const logsToSend = itemsToSend\n      .filter(item => item.kind === 'log')\n      .map(item => (item as { kind: 'log'; value: TelemetryLogData }).value);\n\n    if (eventsToSend.length > 0) {\n      const eventsUrl = new URL('/v1/event', this.#config.endpoint);\n      fetch(eventsUrl, {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        keepalive: true,\n        method: 'POST',\n        // TODO: We send an array here with that idea that we can eventually send multiple events.\n        body: JSON.stringify({ events: eventsToSend }),\n      }).catch(() => void 0);\n    }\n\n    if (logsToSend.length > 0) {\n      const logsUrl = new URL('/v1/logs', this.#config.endpoint);\n      fetch(logsUrl, {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        keepalive: true,\n        method: 'POST',\n        body: JSON.stringify({ logs: logsToSend }),\n      }).catch(() => void 0);\n    }\n  }\n\n  /**\n   * If running in debug mode, log the event and its payload to the console.\n   */\n  #logEvent(event: TelemetryEvent['event'], payload: Record<string, any>) {\n    if (!this.isDebug) {\n      return;\n    }\n\n    if (typeof console.groupCollapsed !== 'undefined') {\n      console.groupCollapsed('[clerk/telemetry]', event);\n      console.log(payload);\n      console.groupEnd();\n    } else {\n      console.log('[clerk/telemetry]', event, payload);\n    }\n  }\n\n  /**\n   * If in browser, attempt to lazily grab the SDK metadata from the Clerk singleton, otherwise fallback to the initially passed in values.\n   *\n   * This is necessary because the sdkMetadata can be set by the host SDK after the TelemetryCollector is instantiated.\n   */\n  #getSDKMetadata() {\n    const sdkMetadata = {\n      name: this.#metadata.sdk,\n      version: this.#metadata.sdkVersion,\n    };\n\n    if (typeof window !== 'undefined') {\n      const windowWithClerk = window as WindowWithClerk;\n\n      if (windowWithClerk.Clerk) {\n        const windowClerk = windowWithClerk.Clerk;\n\n        if (isWindowClerkWithMetadata(windowClerk) && windowClerk.constructor.sdkMetadata) {\n          const { name, version } = windowClerk.constructor.sdkMetadata;\n\n          if (name !== undefined) {\n            sdkMetadata.name = name;\n          }\n          if (version !== undefined) {\n            sdkMetadata.version = version;\n          }\n        }\n      }\n    }\n\n    return sdkMetadata;\n  }\n\n  /**\n   * Append relevant metadata from the Clerk singleton to the event payload.\n   */\n  #preparePayload(event: TelemetryEvent['event'], payload: TelemetryEvent['payload']): TelemetryEvent {\n    const sdkMetadata = this.#getSDKMetadata();\n\n    return {\n      event,\n      cv: this.#metadata.clerkVersion ?? '',\n      it: this.#metadata.instanceType ?? '',\n      sdk: sdkMetadata.name,\n      sdkv: sdkMetadata.version,\n      ...(this.#metadata.publishableKey ? { pk: this.#metadata.publishableKey } : {}),\n      ...(this.#metadata.secretKey ? { sk: this.#metadata.secretKey } : {}),\n      payload,\n    };\n  }\n\n  /**\n   * Best-effort sanitization of the context payload. Returns a plain object with JSON-serializable\n   * values or null when the input is missing or not serializable. Arrays are not accepted.\n   */\n  #sanitizeContext(context: unknown): Record<string, unknown> | null {\n    if (context === null || typeof context === 'undefined') {\n      return null;\n    }\n    if (typeof context !== 'object') {\n      return null;\n    }\n    try {\n      const cleaned = JSON.parse(JSON.stringify(context));\n      if (cleaned && typeof cleaned === 'object' && !Array.isArray(cleaned)) {\n        return cleaned as Record<string, unknown>;\n      }\n      return null;\n    } catch {\n      return null;\n    }\n  }\n}\n","import type { TelemetryEventRaw } from '../../types';\n\nconst EVENT_COMPONENT_MOUNTED = 'COMPONENT_MOUNTED';\nconst EVENT_COMPONENT_OPENED = 'COMPONENT_OPENED';\nconst EVENT_SAMPLING_RATE = 0.1;\n\n/** Increase sampling for high-signal auth components on mount. */\nconst AUTH_COMPONENTS = new Set<string>(['SignIn', 'SignUp']);\n\n/**\n * Returns the per-event sampling rate for component-mounted telemetry events.\n * Uses a higher rate for SignIn/SignUp to improve signal quality.\n *\n *  @internal\n */\nfunction getComponentMountedSamplingRate(component: string): number {\n  return AUTH_COMPONENTS.has(component) ? 1 : EVENT_SAMPLING_RATE;\n}\n\ntype ComponentMountedBase = {\n  component: string;\n};\n\ntype EventPrebuiltComponent = ComponentMountedBase & {\n  appearanceProp: boolean;\n  elements: boolean;\n  variables: boolean;\n  baseTheme: boolean;\n};\n\ntype EventComponentMounted = ComponentMountedBase & TelemetryEventRaw['payload'];\n\n/**\n * Factory for prebuilt component telemetry events.\n *\n * @internal\n */\nfunction createPrebuiltComponentEvent(event: typeof EVENT_COMPONENT_MOUNTED | typeof EVENT_COMPONENT_OPENED) {\n  return function (\n    component: string,\n    props?: Record<string, any>,\n    additionalPayload?: TelemetryEventRaw['payload'],\n  ): TelemetryEventRaw<EventPrebuiltComponent> {\n    return {\n      event,\n      eventSamplingRate:\n        event === EVENT_COMPONENT_MOUNTED ? getComponentMountedSamplingRate(component) : EVENT_SAMPLING_RATE,\n      payload: {\n        component,\n        appearanceProp: Boolean(props?.appearance),\n        baseTheme: Boolean(props?.appearance?.baseTheme),\n        elements: Boolean(props?.appearance?.elements),\n        variables: Boolean(props?.appearance?.variables),\n        ...additionalPayload,\n      },\n    };\n  };\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a prebuilt (AIO) component is mounted.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Will be filtered to a known list of props.\n * @param additionalPayload - Additional data to send with the event.\n * @example\n * telemetry.record(eventPrebuiltComponentMounted('SignUp', props));\n */\nexport function eventPrebuiltComponentMounted(\n  component: string,\n  props?: Record<string, any>,\n  additionalPayload?: TelemetryEventRaw['payload'],\n): TelemetryEventRaw<EventPrebuiltComponent> {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_MOUNTED)(component, props, additionalPayload);\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a prebuilt (AIO) component is opened as a modal.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Will be filtered to a known list of props.\n * @param additionalPayload - Additional data to send with the event.\n * @example\n * telemetry.record(eventPrebuiltComponentOpened('GoogleOneTap', props));\n */\nexport function eventPrebuiltComponentOpened(\n  component: string,\n  props?: Record<string, any>,\n  additionalPayload?: TelemetryEventRaw['payload'],\n): TelemetryEventRaw<EventPrebuiltComponent> {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_OPENED)(component, props, additionalPayload);\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a component is mounted. Use `eventPrebuiltComponentMounted` for prebuilt components.\n *\n * **Caution:** Filter the `props` you pass to this function to avoid sending too much data.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Ideally you only pass a handful of props here.\n * @example\n * telemetry.record(eventComponentMounted('SignUp', props));\n */\nexport function eventComponentMounted(\n  component: string,\n  props: TelemetryEventRaw['payload'] = {},\n): TelemetryEventRaw<EventComponentMounted> {\n  return {\n    event: EVENT_COMPONENT_MOUNTED,\n    eventSamplingRate: getComponentMountedSamplingRate(component),\n    payload: {\n      component,\n      ...props,\n    },\n  };\n}\n","import type { TelemetryEventRaw } from '../../types';\n\nconst EVENT_METHOD_CALLED = 'METHOD_CALLED';\nconst EVENT_SAMPLING_RATE = 0.1;\n\ntype EventMethodCalled = {\n  method: string;\n} & Record<string, string | number | boolean>;\n\n/**\n * Fired when a helper method is called from a Clerk SDK.\n */\nexport function eventMethodCalled(\n  method: string,\n  payload?: Record<string, unknown>,\n): TelemetryEventRaw<EventMethodCalled> {\n  return {\n    event: EVENT_METHOD_CALLED,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload: {\n      method,\n      ...payload,\n    },\n  };\n}\n","import type { TelemetryEventRaw } from '../../types';\n\nconst EVENT_FRAMEWORK_METADATA = 'FRAMEWORK_METADATA';\nconst EVENT_SAMPLING_RATE = 0.1;\n\ntype EventFrameworkMetadata = Record<string, string | number | boolean>;\n\n/**\n * Fired when a helper method is called from a Clerk SDK.\n */\nexport function eventFrameworkMetadata(payload: EventFrameworkMetadata): TelemetryEventRaw<EventFrameworkMetadata> {\n  return {\n    event: EVENT_FRAMEWORK_METADATA,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload,\n  };\n}\n","import type { Appearance, BaseTheme, TelemetryEventRaw } from '../../types';\n\nexport const EVENT_THEME_USAGE = 'THEME_USAGE';\nexport const EVENT_SAMPLING_RATE = 1;\n\ntype EventThemeUsage = {\n  /**\n   * The name of the theme being used (e.g., \"shadcn\", \"neobrutalism\", etc.).\n   */\n  themeName?: string;\n};\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for tracking theme usage in ClerkProvider.\n *\n * @param appearance - The appearance prop from ClerkProvider.\n * @example\n * telemetry.record(eventThemeUsage(appearance));\n */\nexport function eventThemeUsage(appearance?: Appearance): TelemetryEventRaw<EventThemeUsage> {\n  const payload = analyzeThemeUsage(appearance);\n\n  return {\n    event: EVENT_THEME_USAGE,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload,\n  };\n}\n\n/**\n * Analyzes the appearance prop to extract theme usage information for telemetry.\n *\n * @internal\n */\nfunction analyzeThemeUsage(appearance?: Appearance): EventThemeUsage {\n  if (!appearance || typeof appearance !== 'object') {\n    return {};\n  }\n\n  // Prioritize the new theme property over deprecated baseTheme\n  const themeProperty = appearance.theme || appearance.baseTheme;\n\n  if (!themeProperty) {\n    return {};\n  }\n\n  let themeName: string | undefined;\n\n  if (Array.isArray(themeProperty)) {\n    // Look for the first identifiable theme name in the array\n    for (const theme of themeProperty) {\n      const name = extractThemeName(theme);\n      if (name) {\n        themeName = name;\n        break;\n      }\n    }\n  } else {\n    themeName = extractThemeName(themeProperty);\n  }\n\n  return { themeName };\n}\n\n/**\n * Extracts the theme name from a theme object.\n *\n * @internal\n */\nfunction extractThemeName(theme: BaseTheme): string | undefined {\n  if (typeof theme === 'string') {\n    return theme;\n  }\n\n  if (typeof theme === 'object' && theme !== null) {\n    // Check for explicit theme name\n    if ('name' in theme && typeof theme.name === 'string') {\n      return theme.name;\n    }\n  }\n\n  return undefined;\n}\n","/**\n * src/lib/billing.ts\n *\n * Billing / subscription / usage helpers used by workers and API routes.\n *\n * - Resolves tenant membership for a user (team_members).\n * - Fetches subscription status (tenant_subscriptions).\n * - Gets or creates usage counters (usage_counters) idempotently and robustly.\n * - Provides requireSubscriptionAndUsage() which enforces subscription/quota unless\n *   the user is an owner/admin (owner bypass).\n *\n * Notes:\n * - If team membership is missing, you can enable a synthetic-tenant bypass for creators\n *   by setting ALLOW_SYNTHETIC_TENANT_FOR_CREATORS=1 in the environment. This will treat\n *   tenantId = requestedTenantId || userId and role = 'owner' for that call (opt-in).\n * - getOrCreateUsageRow handles duplicate key races by re-selecting after duplicate errors.\n */\n\nimport { NextResponse } from \"next/server\";\nimport { clerkClient } from \"@clerk/nextjs/server\";\nimport { HttpError } from \"./errors\";\nimport { getServiceSupabaseClient } from \"./supabase\";\nimport { getOwnerEmails, normalizeEmail } from \"./owners\";\n\nexport type TenantRole = \"owner\" | \"admin\" | \"member\";\nexport type UsageFeature = \"ingestion\" | \"seo\" | \"variants\" | \"match\";\n\nconst FEATURE_COLUMNS: Record<\n  UsageFeature,\n  { column: string; quotaKey: keyof SubscriptionStatus[\"quotas\"] }\n> = {\n  ingestion: { column: \"ingestion_count\", quotaKey: \"ingestion\" },\n  seo: { column: \"seo_count\", quotaKey: \"seo\" },\n  variants: { column: \"variants_count\", quotaKey: \"variants\" },\n  match: { column: \"match_count\", quotaKey: \"match\" },\n};\n\nexport interface SubscriptionStatus {\n  planName: string | null;\n  status: string | null;\n  currentPeriodEnd: string | null;\n  quotas: {\n    ingestion: number | null;\n    seo: number | null;\n    variants: number | null;\n    match: number | null;\n  };\n  isActive: boolean;\n}\n\nexport interface UsageSnapshot {\n  id: string;\n  tenant_id: string;\n  period_start: string;\n  ingestion_count: number;\n  seo_count: number;\n  variants_count: number;\n  match_count: number;\n  updated_at?: string;\n}\n\nexport interface TenantContext {\n  tenantId: string;\n  role: TenantRole;\n  subscription: SubscriptionStatus;\n  usage: UsageSnapshot;\n}\n\n/* -------------------------\n   Helpers\n   ------------------------- */\n\nasync function resolveOwnerOverride(userId: string, userEmail?: string): Promise<boolean> {\n  const ownerEmails = getOwnerEmails();\n  if (!ownerEmails || ownerEmails.length === 0) return false;\n\n  const normalizedEmail = normalizeEmail(userEmail);\n  if (normalizedEmail) {\n    return ownerEmails.includes(normalizedEmail);\n  }\n\n  try {\n    const clerk = await clerkClient();\n    const user = await clerk.users.getUser(userId);\n    const primary =\n      normalizeEmail(user.primaryEmailAddress?.emailAddress) ||\n      normalizeEmail(user.emailAddresses?.[0]?.emailAddress);\n    if (!primary) return false;\n    return ownerEmails.includes(primary);\n  } catch (err) {\n    console.warn(\"billing.resolveOwnerOverride: clerk lookup failed (non-fatal)\", (err as any)?.message ?? err);\n    return false;\n  }\n}\n\nfunction isSubscriptionActive(status: string | null | undefined): boolean {\n  if (!status) return false;\n  return [\"active\", \"trialing\", \"paid\"].includes(status);\n}\n\nexport function tenantFromRequest(req: Request): string | undefined {\n  const headerTenant = req.headers.get(\"x-tenant-id\");\n  if (headerTenant) return headerTenant;\n  const url = new URL(req.url);\n  return url.searchParams.get(\"tenant_id\") ?? undefined;\n}\n\n/* -------------------------\n   Membership & subscription\n   ------------------------- */\n\nasync function resolveTenantMembership(userId: string, requestedTenantId?: string): Promise<{ tenantId: string; role: TenantRole }> {\n  const supabase = getServiceSupabaseClient();\n  let query = supabase\n    .from(\"team_members\")\n    .select(\"tenant_id, role\")\n    .eq(\"user_id\", userId)\n    .order(\"created_at\", { ascending: true })\n    .limit(1);\n\n  if (requestedTenantId) query = query.eq(\"tenant_id\", requestedTenantId);\n\n  const { data, error } = await query;\n  if (error) {\n    throw new Error(error.message);\n  }\n  const membership = data?.[0];\n  if (!membership) {\n    throw new HttpError(403, \"No tenant membership found for user.\");\n  }\n  return { tenantId: membership.tenant_id, role: membership.role as TenantRole };\n}\n\nasync function fetchSubscription(tenantId: string): Promise<SubscriptionStatus> {\n  const supabase = getServiceSupabaseClient();\n  const { data, error } = await supabase\n    .from(\"tenant_subscriptions\")\n    .select(\"plan_name, status, current_period_end, ingestion_quota, seo_quota, variant_quota, match_quota\")\n    .eq(\"tenant_id\", tenantId)\n    .order(\"current_period_end\", { ascending: false })\n    .limit(1);\n\n  if (error) {\n    throw new Error(error.message);\n  }\n\n  const row = data?.[0];\n  return {\n    planName: row?.plan_name ?? null,\n    status: row?.status ?? null,\n    currentPeriodEnd: row?.current_period_end ?? null,\n    quotas: {\n      ingestion: row?.ingestion_quota ?? null,\n      seo: row?.seo_quota ?? null,\n      variants: row?.variant_quota ?? null,\n      match: row?.match_quota ?? null,\n    },\n    isActive: isSubscriptionActive(row?.status ?? null),\n  };\n}\n\n/* -------------------------\n   Usage counters (idempotent)\n   ------------------------- */\n\nasync function getOrCreateUsageRow(tenantId: string): Promise<UsageSnapshot> {\n  const supabase = getServiceSupabaseClient();\n\n  // 1) Attempt to read the latest usage row\n  const { data, error } = await supabase\n    .from(\"usage_counters\")\n    .select(\"id, tenant_id, period_start, ingestion_count, seo_count, variants_count, match_count, updated_at\")\n    .eq(\"tenant_id\", tenantId)\n    .order(\"period_start\", { ascending: false })\n    .limit(1);\n\n  if (error) {\n    // bubble up; caller can surface a migration hint\n    throw new Error(error.message);\n  }\n\n  if (data && data.length > 0) {\n    const row = data[0];\n    return {\n      id: row.id,\n      tenant_id: row.tenant_id,\n      period_start: row.period_start,\n      ingestion_count: row.ingestion_count ?? 0,\n      seo_count: row.seo_count ?? 0,\n      variants_count: row.variants_count ?? 0,\n      match_count: row.match_count ?? 0,\n      updated_at: row.updated_at ?? undefined,\n    };\n  }\n\n  // 2) No existing row: try insert, but tolerate race/unique constraint by re-selecting\n  const today = new Date().toISOString().slice(0, 10);\n  try {\n    const { data: inserted, error: insertError } = await supabase\n      .from(\"usage_counters\")\n      .insert({ tenant_id: tenantId, period_start: today })\n      .select(\"id, tenant_id, period_start, ingestion_count, seo_count, variants_count, match_count, updated_at\")\n      .limit(1);\n\n    if (insertError) {\n      const msg = String(insertError.message || \"\").toLowerCase();\n      // If duplicate/unique constraint race, re-select\n      if (msg.includes(\"duplicate\") || msg.includes(\"unique\")) {\n        const { data: after, error: afterErr } = await supabase\n          .from(\"usage_counters\")\n          .select(\"id, tenant_id, period_start, ingestion_count, seo_count, variants_count, match_count, updated_at\")\n          .eq(\"tenant_id\", tenantId)\n          .order(\"period_start\", { ascending: false })\n          .limit(1);\n        if (afterErr) throw new Error(afterErr.message);\n        if (after && after.length > 0) {\n          const row = after[0];\n          return {\n            id: row.id,\n            tenant_id: row.tenant_id,\n            period_start: row.period_start,\n            ingestion_count: row.ingestion_count ?? 0,\n            seo_count: row.seo_count ?? 0,\n            variants_count: row.variants_count ?? 0,\n            match_count: row.match_count ?? 0,\n            updated_at: row.updated_at ?? undefined,\n          };\n        }\n      }\n      // Other insert error: surface\n      throw new Error(insertError.message);\n    }\n\n    const insertedRow = inserted?.[0];\n    return {\n      id: insertedRow.id,\n      tenant_id: insertedRow.tenant_id,\n      period_start: insertedRow.period_start,\n      ingestion_count: insertedRow.ingestion_count ?? 0,\n      seo_count: insertedRow.seo_count ?? 0,\n      variants_count: insertedRow.variants_count ?? 0,\n      match_count: insertedRow.match_count ?? 0,\n      updated_at: insertedRow.updated_at ?? undefined,\n    };\n  } catch (err: any) {\n    const msg = String(err?.message || err || \"\").toLowerCase();\n    if (msg.includes(\"does not exist\") || msg.includes('relation \"usage_counters\"')) {\n      throw new Error(\"usage_counters table missing or schema mismatch. Run migrations.\");\n    }\n    throw err;\n  }\n}\n\nasync function incrementUsage(usage: UsageSnapshot, feature: UsageFeature, amount: number): Promise<UsageSnapshot> {\n  const supabase = getServiceSupabaseClient();\n  const { column } = FEATURE_COLUMNS[feature];\n  const newValue = (usage[column as keyof UsageSnapshot] as number) + amount;\n\n  const { error } = await supabase\n    .from(\"usage_counters\")\n    .update({ [column]: newValue, updated_at: new Date().toISOString() })\n    .eq(\"id\", usage.id);\n\n  if (error) {\n    throw new Error(error.message);\n  }\n\n  return {\n    ...usage,\n    [column]: newValue,\n  } as UsageSnapshot;\n}\n\n/* -------------------------\n   Tenant context resolution\n   ------------------------- */\n\nexport async function getTenantContextForUser({\n  userId,\n  requestedTenantId,\n  userEmail,\n}: {\n  userId: string;\n  requestedTenantId?: string;\n  userEmail?: string;\n}): Promise<TenantContext> {\n  // 1) Try to resolve membership. If missing, allow synthetic tenant OR owner override.\n  let membershipResult: { tenantId: string; role: TenantRole } | null = null;\n  try {\n    membershipResult = await resolveTenantMembership(userId, requestedTenantId);\n  } catch (err) {\n    // membership not found -> check synthetic bypass env\n    const allowSynthetic = process.env.ALLOW_SYNTHETIC_TENANT_FOR_CREATORS === \"1\";\n    if (allowSynthetic) {\n      const tenantId = requestedTenantId ?? userId;\n      console.warn(\n        `billing: membership missing for ${userId}; using synthetic tenant=${tenantId} because ALLOW_SYNTHETIC_TENANT_FOR_CREATORS=1`\n      );\n      membershipResult = { tenantId, role: \"owner\" };\n    } else {\n      // owner override via owner email list or Clerk\n      const ownerOverride = await resolveOwnerOverride(userId, userEmail);\n      if (ownerOverride) {\n        const tenantId = requestedTenantId ?? userId;\n        console.warn(`billing: membership missing for ${userId}; owner override applied, tenant=${tenantId}`);\n        membershipResult = { tenantId, role: \"owner\" };\n      } else {\n        // rethrow original membership error\n        throw err;\n      }\n    }\n  }\n\n  // 2) If role owner -> return synthetic context that bypasses subscription/usage checks.\n  if (membershipResult.role === \"owner\") {\n    const usage: UsageSnapshot = {\n      id: \"\",\n      tenant_id: membershipResult.tenantId,\n      period_start: new Date().toISOString().slice(0, 10),\n      ingestion_count: 0,\n      seo_count: 0,\n      variants_count: 0,\n      match_count: 0,\n      updated_at: new Date().toISOString(),\n    };\n    const subscription: SubscriptionStatus = {\n      planName: null,\n      status: \"owner-bypass\",\n      currentPeriodEnd: null,\n      quotas: { ingestion: null, seo: null, variants: null, match: null },\n      isActive: true,\n    };\n\n    return {\n      tenantId: membershipResult.tenantId,\n      role: \"owner\",\n      subscription,\n      usage,\n    };\n  }\n\n  // 3) Non-owner path: fetch subscription & usage normally\n  const subscription = await fetchSubscription(membershipResult.tenantId);\n  const usage = await getOrCreateUsageRow(membershipResult.tenantId);\n\n  // Cast role to TenantRole explicitly to satisfy TypeScript (membershipResult.role may be narrowed)\n  const roleStr = membershipResult.role as TenantRole;\n  const hasOwnerOverride = roleStr === \"owner\" ? true : await resolveOwnerOverride(userId, userEmail);\n  const role: TenantRole = hasOwnerOverride ? \"owner\" : membershipResult.role;\n\n  return {\n    tenantId: membershipResult.tenantId,\n    role,\n    subscription,\n    usage,\n  };\n}\n\n/* -------------------------\n   Public: requireSubscriptionAndUsage\n   ------------------------- */\n\nexport async function requireSubscriptionAndUsage({\n  userId,\n  requestedTenantId,\n  feature,\n  increment = 1,\n  userEmail,\n}: {\n  userId: string;\n  requestedTenantId?: string;\n  feature?: UsageFeature;\n  increment?: number;\n  userEmail?: string;\n}): Promise<TenantContext> {\n  const context = await getTenantContextForUser({ userId, requestedTenantId, userEmail });\n  const isOwner = context.role === \"owner\";\n\n  if (!isOwner && !context.subscription.isActive) {\n    throw new HttpError(402, \"An active subscription is required for this action.\");\n  }\n\n  if (feature) {\n    const { quotaKey } = FEATURE_COLUMNS[feature];\n    const quota = context.subscription.quotas[quotaKey];\n    const currentUsage = context.usage[FEATURE_COLUMNS[feature].column as keyof UsageSnapshot] as number;\n    const projected = currentUsage + increment;\n\n    if (!isOwner && quota !== null && projected > quota) {\n      throw new HttpError(402, \"Quota exceeded for this plan. Please upgrade to continue.\");\n    }\n\n    // Only increment usage for non-synthetic DB-backed usage rows. If usage.id is empty,\n    // it means owner-synthetic context (no DB row) so skip increment.\n    if (context.usage.id) {\n      const updatedUsage = await incrementUsage(context.usage, feature, increment);\n      return { ...context, usage: updatedUsage };\n    } else {\n      // synthetic owner usage: return context with usage unchanged (treated as allowed)\n      return context;\n    }\n  }\n\n  return context;\n}\n\n/* -------------------------\n   Error handler for routes\n   ------------------------- */\n\nexport function handleRouteError(error: unknown) {\n  if (error instanceof HttpError) {\n    return NextResponse.json({ error: error.message }, { status: error.status });\n  }\n  console.error(error);\n  return NextResponse.json({ error: \"Internal server error\" }, { status: 500 });\n}\n","export class HttpError extends Error {\n  status: number;\n\n  constructor(status: number, message: string) {\n    super(message);\n    this.status = status;\n    this.name = 'HttpError';\n  }\n}\n","export function normalizeEmail(email?: string | null): string | undefined {\n  if (!email) {\n    return undefined;\n  }\n  const normalized = email.trim().toLowerCase();\n  return normalized.length ? normalized : undefined;\n}\n\nexport function getOwnerEmails(): string[] {\n  const source = process.env.OWNER_EMAILS;\n  if (!source) {\n    return [];\n  }\n  return source\n    .split(',')\n    .map((email) => normalizeEmail(email) ?? '')\n    .filter((email): email is string => Boolean(email));\n}\n","export function extractEmailFromSessionClaims(\n  sessionClaims: Record<string, unknown> | null | undefined,\n): string | undefined {\n  if (!sessionClaims) {\n    return undefined;\n  }\n\n  const claims = sessionClaims as Record<string, unknown>;\n  const keys = ['email', 'email_address'];\n  for (const key of keys) {\n    const value = claims[key];\n    if (typeof value === 'string' && value.length > 0) {\n      return value;\n    }\n  }\n\n  const addressList = claims['email_addresses'];\n  if (Array.isArray(addressList)) {\n    const first = addressList.find((value) => typeof value === 'string') as string | undefined;\n    if (first) {\n      return first;\n    }\n  }\n\n  return undefined;\n}\n"],"names":["#cache","#cacheTtl","sanitizedEvent: Omit<TelemetryEvent, 'sk' | 'pk' | 'payload'> & TelemetryEvent['payload']","#getCache","#storageKey","err: unknown","#maxSize","DEFAULT_CONFIG: Partial<TelemetryCollectorConfig>","#config","#metadata","#eventThrottler","#preparePayload","#logEvent","#shouldRecord","#buffer","#scheduleFlush","#shouldRecordLog","normalizedTimestamp: Date | null","timestampInput: unknown","#getSDKMetadata","logData: TelemetryLogData","#sanitizeContext","#shouldBeSampled","#flush","#pendingFlush","EVENT_SAMPLING_RATE","themeName: string | undefined"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12]}